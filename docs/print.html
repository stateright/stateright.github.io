<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Distributed Systems With Stateright</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Building Distributed Systems With Stateright</a></li><li class="chapter-item expanded affix "><li class="part-title">Concepts</li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Protocols</li><li class="chapter-item expanded "><a href="taming-the-network.html"><strong aria-hidden="true">2.</strong> Taming the Network</a></li><li class="chapter-item expanded "><a href="seeking-consensus.html"><strong aria-hidden="true">3.</strong> Seeking Consensus</a></li><li class="chapter-item expanded "><a href="achieving-linearizability.html"><strong aria-hidden="true">4.</strong> Achieving Linearizability</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Achieving Consensus</div></li><li class="chapter-item expanded affix "><li class="part-title">Other Topics</li><li class="chapter-item expanded "><a href="comparison-with-tlaplus.html"><strong aria-hidden="true">6.</strong> Comparison with TLA+</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Building Distributed Systems With Stateright</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/stateright/stateright.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p><img src="https://img.shields.io/badge/Library_Links:-gray" alt="links" />
<a href="https://discord.gg/JbxGSVP4A6"><img src="https://img.shields.io/discord/781357978652901386" alt="chat" /></a>
<a href="https://crates.io/crates/stateright"><img src="https://img.shields.io/crates/d/stateright.svg" alt="crates.io" /></a>
<a href="https://docs.rs/stateright"><img src="https://docs.rs/stateright/badge.svg" alt="docs.rs" /></a>
<a href="https://github.com/stateright/stateright"><img src="https://img.shields.io/github/stars/stateright/stateright?style=social" alt="stars" /></a></p>
</blockquote>
<h1><a class="header" href="#building-distributed-systems-with-stateright" id="building-distributed-systems-with-stateright">Building Distributed Systems With Stateright</a></h1>
<p><em>by Jonathan Nadal</em></p>
<blockquote>
<p>Deep understanding of causality sometimes requires the understanding of very
large patterns and their abstract relationships and interactions, not just the
understanding of microscopic objects interacting in microscopic time intervals.</p>
<p>― Douglas R. Hofstadter, <em>I Am a Strange Loop</em></p>
</blockquote>
<p>Distributed computing is a term that refers to multiple computers working
together <em>as a system</em> to solve a problem, typically because that problem would
not be solvable on a single computer. For example, we all want to know that our
important files will be accessible even when computer hardware inevitably
fails. As a second example, a researcher at a pharmaceutical company may have a
complex problem that would take decades for a single computer to solve, but
which a collection of computers working together could solve in days.</p>
<p>Unique algorithms must be employed to coordinate workloads across these
geographically distributed systems of computers because they are susceptible to
categories of nondeterminism that do not arise when a problem is solved with a
single computer. For example, the networks that link these computers will drop,
reorder, and even redeliver messages. Algorithms that fail to account for this
behavior may run correctly for extended periods but will eventually fail at
unpredicatable times in unpredictable ways, such as causing data corruption.</p>
<p>Stateright is a software framework for analyzing and systematically verifying
distributed systems. Its name refers to the goal of verifying that a system's
collective state always satisfies a correctness specification, such as &quot;any
data written to the system should be accessible as long as at least one data
center is reachable.&quot;</p>
<p>Cloud service providers like AWS and Azure leverage verification software such
as <a href="https://lamport.azurewebsites.net/tla/industrial-use.html">the TLA+ model
checker</a> to achieve
the same goal, but whereas those solutions typically verify a high level system
design, Stateright is able to verify the underlying system <em>implementation</em> in
addition to the design (along with providing other unique benefits explained in
the &quot;<a href="./comparison-with-tlaplus.html">Comparison with TLA+</a>&quot; chapter). On the
other end of the spectrum are tools such as <a href="https://jepsen.io/">Jepsen</a> which
can validate a final implementation by testing a random subset of the system's
behavior, whereas Stateright can systematically enumerate all possible
behaviors within a specified model of the system.</p>
<p>We'll jump right in with a motivating example in the first chapter, <a href="./getting-started.html">Getting
Started</a>. Please see the <a href="https://www.youtube.com/playlist?list=PLUhyBsVvEJjaF1VpNhLRfIA4E7CFPirmz">Stateright YouTube
channel</a>
if you prefer starting with a video introduction.</p>
<h1><a class="header" href="#chapter-1-getting-started" id="chapter-1-getting-started">Chapter 1: Getting Started</a></h1>
<blockquote>
<p><strong>IMPORTANT</strong>: Stateright is a relatively new framework and will be making breaking API
changes leading up to a 1.0 release, at which point the API will be considered
stable. If you plan to use Stateright for production scenarios, then please
<a href="https://github.com/stateright/stateright/issues/new">file a GitHub issue</a> so
that the author can coordinate with you to minimize any disruption.</p>
</blockquote>
<h2><a class="header" href="#staterights-value-proposition" id="staterights-value-proposition">Stateright's Value Proposition</a></h2>
<p>Stateright is a Rust library that simplifies implementing distributed systems
while more importantly providing a powerful mechanism for verification.</p>
<p>Verification of distributed systems is difficult because distributed algorithms
must be resilient to nondeterminism caused by concurrency such as threads
racing, but that's only part of the challenge.  Distributed algorithms also
need to account for the fact that computers typically interface via <a href="https://aphyr.com/posts/288-the-network-is-reliable">unreliable
networks</a> that will
periodically do things like reorder or lose messages (if you run your system in
&quot;the cloud,&quot; then it's running on an unreliable network).  Furthermore, often a
distributed algorithm is expected to continue working even if a subset of
computers crash at arbitrary points in their execution.  Designing algorithms
that continue working in the presence of this added nondeterminism is
nontrivial and error prone, which necessitates special tools for verifying
correctness.</p>
<p>One approach to verifying the correctness of distributed algorithms is to run
them in an environment that randomly introduces nondeterminism more frequently
than a normal environment would. This is the approach taken by
<a href="https://jepsen.io/analyses">Jepsen</a>, and it has proven to be incredibly
effective, finding bugs in distributed systems such as
<a href="https://jepsen.io/analyses/etcd-3.4.3">etcd</a>,
<a href="https://jepsen.io/analyses/postgresql-12.3">PostgreSQL</a>,
<a href="https://aphyr.com/posts/283-call-me-maybe-redis">Redis</a>, and
<a href="https://aphyr.com/posts/291-call-me-maybe-zookeeper">Zookeeper</a> among many
others.</p>
<p>Stateright's approach is similar, but rather than testing a random subset of
possible behaviors, it tests <em>all possible observable behaviors</em> within a
particular specification.  The catch is that Stateright needs to be embedded
into the system's implementation, whereas solutions such as Jepsen do not,
making them amenable to testing a wider range of software; but if you are
writing a distributed system in Rust, then Stateright can provide additional
verification over random testing.</p>
<h2><a class="header" href="#an-example" id="an-example">An Example</a></h2>
<p>Let's start with a very simple distributed system: a
single client that can interact with a single server by
reading or writing a value. We'll see that even this
minimal example is susceptible to surprising behavior.</p>
<p><a href="https://www.rust-lang.org/learn/get-started">Install the Rust programming
language</a> if it is not already
installed, then initialize a new project using the <code>cargo</code> utility included
with Rust. If you are new to Rust, then you should also review some of the
language's <a href="https://www.rust-lang.org/learn">learning resources</a>.</p>
<pre><code class="language-sh">mkdir getting-started
cd getting-started
cargo init
</code></pre>
<p>Define dependencies in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[package]
name = &quot;getting-started&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
env_logger = &quot;0.7&quot;
serde_json = &quot;1.0&quot;
stateright = &quot;0.23&quot;
</code></pre>
<p>Here is the complete implementation for <code>main.rs</code>. Copy-paste it into your own
file. The subsequent sections will explain further.</p>
<pre><code class="language-rust ignore noplayground">use stateright::actor::{*, register::*};
use std::borrow::Cow; // COW == clone-on-write
use std::net::{SocketAddrV4, Ipv4Addr};

type RequestId = u64;

#[derive(Clone)]
struct ActorContext;

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = char;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        '?' // default value for the register
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                *state.to_mut() = value;
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, **state));
            }
            _ =&gt; {}
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use stateright::*;
    use RegisterMsg::{Get, GetOk, Put, PutOk};
    use SystemAction::Deliver;

    #[test]
    fn is_unfortunately_not_linearizable() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(1) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(2, 'Z') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(2) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Get(3) },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: GetOk(3, 'A') },
        ]);
    }
}

fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000), ActorContext)
        ]).unwrap();
}
</code></pre>
<h2><a class="header" href="#actor-framework-intro" id="actor-framework-intro">Actor Framework Intro</a></h2>
<p>The code implements a simple server using the <a href="https://en.wikipedia.org/wiki/Actor_model">actor
model</a>  in which an &quot;actor&quot; is an
object that can respond to events (such as timeouts or message receipt) and in
turn updates its internal state and generates outputs (such as sending a
message or setting a timer).</p>
<p>If you are familiar with the actor model (e.g. via the
<a href="https://www.erlang.org/">Erlang</a> language or the <a href="https://akka.io/">Akka</a>
library), then it is useful to note distinguishing characteristics of
Stateright's approach:</p>
<ol>
<li>Stateright <strong>must have visibility of every input and output</strong> to facilitate
simulating all possible system behaviors. That means inputs and outputs must
be in the form of messages. For example, if your actor needs to interface
with a database, you might introduce <code>DbExec(...)</code> output and
<code>DbResult(...)</code> input messages; or if it needs to interface with the file
system, you might introduce <code>FileRead(...)</code> output and <code>FileResult(...)</code>
input messages. An adapter layer would then translate these into/from the
corresponding effects rather than treating them as standard messages between
actors in the system. This technique will be demonstrated in a later
chapter.</li>
<li>Outputs <strong>do not take effect until after the handler returns</strong>. The outputs
are simply collected in the <a href="https://docs.rs/stateright/latest/stateright/actor/struct.Out.html"><code>o: &amp;mut Out&lt;Self&gt;</code></a>
parameter whenever methods such as
<a href="https://docs.rs/stateright/latest/stateright/actor/struct.Out.html#method.send"><code>Out::send(...)</code></a>
are called, and Stateright's actor runtime sends them later.</li>
<li>The <strong>actor state is only accessible via a clone-on-write cell</strong> with the
<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>state: &amp;mut Cow&lt;Self::State&gt;</code></a>
parameter. Doing so enables Stateright to more efficiently validate a system
when it is enumerating different branches of nondeterministic behavior.</li>
</ol>
<h2><a class="header" href="#model-checking-in-more-detail" id="model-checking-in-more-detail">Model Checking in More Detail</a></h2>
<p>The reference to &quot;enumerating different branches of nondeterministic behavior&quot;
deserves additional explanation. The nondeterminism within a nondeterministic
system is never completely open ended. Instead there are &quot;decision points&quot; that
arise, where a &quot;decision&quot; isn't directly made by your code but rather is the
weighted random outcome of many factors. For example, if two clients
concurrently initiate requests to a service, then the initial &quot;decision&quot; would
be:</p>
<ol>
<li>the first client's request is delivered causing the service to respond,</li>
<li>the second client's request is delivered causing the service to respond,</li>
<li>or both clients time out while contacting the service.</li>
</ol>
<p>If option 1 occurs, then it can be followed by option 2, and vice versa. In
both cases, timeouts are also possible. In this manner the possible behaviors
of a nondeterministic system can be seen as a decision tree.</p>
<p><img src="getting-started.states.svg" alt="decision diagram showing possible states" /></p>
<p>At each of these decision points, Stateright will explore one of the outcomes
and then backtrack to expore the other outcome. This is the distinguishing
characteristic of model checking in comparison with random testing. Also, each
gray box indicates a potential state of the aggregate system (where the
aggregate system state includes the client state, the service state, and the
network state), and the collection of all potential aggregate states is known
as the &quot;state space.&quot;</p>
<h2><a class="header" href="#implementation-walkthrough" id="implementation-walkthrough">Implementation Walkthrough</a></h2>
<p>The server responds to <code>Put</code> and <code>Get</code> messages based only on its own local
state, providing its clients with a simple form of distributed storage,
sometimes known as a <a href="https://en.wikipedia.org/wiki/Shared_register">shared
register</a>.  Responses are linked
to requests via a request ID chosen by the client.</p>
<pre><code class="language-rust ignore noplayground">type RequestId = u64;

#[derive(Clone)]
struct ActorContext;

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = char;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        '?' // default value for the register
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                *state.to_mut() = value;
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, **state));
            }
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>A test follows. The test checks the system for a property called
<a href="https://en.wikipedia.org/wiki/Linearizability">linearizability</a>, which loosely
speaking means that the visible behavior of the register emulated by the actor
system is identical to that of a register within a single-threaded system. In
the words of the individuals who coined the term:</p>
<blockquote>
<p>Linearizability provides the illusion that each operation applied by
concurrent processes takes effect instantaneously at some point between its
invocation and its response, implying that the meaning of a concurrent object’s
operations can be given by pre- and post-conditions.</p>
<ul>
<li>Maurice Herlihy and Jeannette Wing, in <a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.142.5315">Linearizability: A Correctness
Condition for Concurrent
Objects</a></li>
</ul>
</blockquote>
<p>An important aspect of linearizability is the notion of a &quot;sequential
specification,&quot; which serves as a reference for correct behavior of the system.
In other words, the system <em>emulates</em> the sequential specification.
For instance, the sequential specification could indicate:</p>
<ul>
<li>the system behaves like a memory cell (i.e. register semantics),</li>
<li>the system behaves like a queue,</li>
<li>or the system behaves like a stack.</li>
</ul>
<p>That means that when someone indicates that a system is linearizable, it is
important to keep in mind the question &quot;linearizable with respect to <em>what</em>?&quot;
In this chapter, the sequential specification is register semantics, provided
by Stateright, but later chapters will involve other sequential specifications.</p>
<p>The test leverages
<a href="https://docs.rs/stateright/latest/stateright/actor/register/struct.RegisterTestSystem.html"><code>RegisterTestSystem</code></a>,
which is built into Stateright and defines a system whereby a specified number
of clients (only 1 in this case) write distinct values and independently read
values without coordinating with one another. Under the hood
<code>RegisterTestSystem</code> also leverages Stateright's built-in
<a href="https://docs.rs/stateright/latest/stateright/semantics/struct.LinearizabilityTester.html"><code>LinearizabilityTester</code></a>.</p>
<pre><code class="language-rust ignore noplayground">    #[test]
    fn is_unfortunately_not_linearizable() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(1) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(2, 'Z') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(2) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Get(3) },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: GetOk(3, 'A') },
        ]);
    }
</code></pre>
<p>Stateright is able to find a bug that arises even if there is only a single
client. The test indicates a sequence of steps that trigger the bug (AKA a
<a href="https://docs.rs/stateright/0.23.0/stateright/struct.Path.html"><code>Path</code></a>), but
in practice you would normally just call <code>checker.assert_properties()</code>, and
Stateright would fail the test while indicating steps that reproduce the bug
(although the specific example that it finds can vary).</p>
<p>The actor with <code>Id</code> 0 is the server while the actor with <code>Id</code> 1 is the client.
For brevity, the example shows actor inputs (<code>Deliver</code>) but not outputs.</p>
<p><img src="getting-started.sequence.png" alt="sequence diagram for the linearizability violation" /></p>
<ol>
<li>The server receives a <code>Put</code> from the client with value <code>'A'</code>, which it
acknowledges. The client receives the <code>PutOk</code> acknowledgement and in turn
sends a second <code>Put</code> with a new value, <code>'Z'</code> (not shown yet since the test
indicates message deliveries only, not message sends).
<pre><code>Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(1) },
</code></pre>
</li>
<li>The server receives the second <code>Put</code>, which it acknowledges. The client
receives the <code>PutOk</code> acknowledgement and in turn sends a <code>Get</code> request (not
shown yet), expecting to read <code>'Z'</code>.
<pre><code>Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(2, 'Z') },
Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(2) },
</code></pre>
</li>
<li>The network redelivers the first write, inadvertently overwriting the second:
<pre><code>Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
</code></pre>
</li>
<li>The server receives the earlier <code>Get</code> request and replies with <code>'A'</code>. The
client receives the unexpected value, which violates linearizability because
from the perspective of the client, the system is not behaving as a
single-threaded register.
<pre><code>Deliver { src: Id::from(1), dst: Id::from(0), msg: Get(3) },
Deliver { src: Id::from(0), dst: Id::from(1), msg: GetOk(3, 'A') },
</code></pre>
</li>
</ol>
<p>The last bit of code defines the <code>main</code> method, which allows you to run the
actor on UDP port 3000, encoding messages with the JSON format.</p>
<pre><code class="language-rust ignore noplayground">fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000), ActorContext)
        ]).unwrap();
}
</code></pre>
<h2><a class="header" href="#running" id="running">Running</a></h2>
<p>Confirm the system behaves as expected by running the test, which should pass
because the test asserts that the bug exists. Include the <code>--release</code> flag so
that Rust fully optimizes the code even during testing, as Stateright tests are
computationally intensive and can be time consuming.</p>
<pre><code class="language-sh">cargo test --release
</code></pre>
<p>Now run the actor on a UDP socket.</p>
<pre><code class="language-sh">cargo run --release
</code></pre>
<p>If using a POSIX-oriented operating system,
<a href="https://en.wikipedia.org/wiki/Netcat">netcat</a> can be used to interact with the
actor from a different terminal window. Actor responses are omitted from the
listing below for clarity, but you will see messages such as <code>{&quot;PutOk&quot;:0}</code>
printed to STDOUT. Numbers in the messages are request IDs, the importance of
which will be more evident in the next chapter.</p>
<pre><code class="language-sh">nc -u localhost 3000
{&quot;Put&quot;:[0,&quot;X&quot;]}
{&quot;Get&quot;:1}
{&quot;Put&quot;:[2,&quot;X&quot;]}
{&quot;Get&quot;:3}
</code></pre>
<h2><a class="header" href="#exercise" id="exercise">Exercise</a></h2>
<p>Uncomment the <code>// TRY IT</code> line, then run the test again. It should fail
indicating a sequence of steps that would cause the linearizability expectation
to be violated, and these steps may differ from the example that we followed.
This exercise demonstrates how Stateright can detect flaws that would likely go
undetected when simply reviewing code.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>This chapter introduced one of the simplest possible distributed systems and
showed how Stateright can find a subtle bug. The next chapter <a href="./taming-the-network.html">Taming the
Network</a> will address that bug.</p>
<h1><a class="header" href="#chapter-2-taming-the-network" id="chapter-2-taming-the-network">Chapter 2: Taming the Network</a></h1>
<p>In the last chapter we discovered a bug caused by the network's susceptibility
to message redelivery. We address that in this chapter.</p>
<p>Initialize a new Rust project:</p>
<pre><code class="language-sh">mkdir taming-the-network
cd taming-the-network
cargo init
</code></pre>
<p>Then add dependencies to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;taming-the-network&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
env_logger = &quot;0.7&quot;
serde_json = &quot;1.0&quot;
stateright = &quot;0.23&quot;
</code></pre>
<p>Here is the complete implementation for <code>main.rs</code>, explained below:</p>
<pre><code class="language-rust ignore noplayground">
use stateright::actor::{*, register::*};
use std::borrow::Cow;
use std::collections::BTreeSet;
use std::net::{SocketAddrV4, Ipv4Addr};

type RequestId = u64;

#[derive(Clone)]
struct ActorContext;

#[derive(Clone, Debug, Hash, PartialEq)]
struct ActorState {
    value: char,
    delivered: BTreeSet&lt;(Id, RequestId)&gt;,
}

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = ActorState;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        ActorState {
            value: '?',
            delivered: Default::default(),
        }
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, state.value));
            }
            _ =&gt; {}
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use stateright::*;
    use RegisterMsg::{Get, GetOk, Put, PutOk};
    use SystemAction::Deliver;

    #[test]
    fn satisfies_all_properties() {
        // Works with 1 client.
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        checker.assert_properties();

        // Or with multiple clients.
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 2, // TIP: test with `--release` mode for more clients
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        checker.assert_properties();
    }

    #[test]
    fn not_linearizable_with_two_servers() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext, ActorContext], // two servers
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Put(2, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(2), msg: PutOk(2) },
            Deliver { src: Id::from(2), dst: Id::from(1), msg: Put(4, 'Z') },
            Deliver { src: Id::from(1), dst: Id::from(2), msg: PutOk(4) },
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Get(6) },
            Deliver { src: Id::from(0), dst: Id::from(2), msg: GetOk(6, 'A') },
        ]);
    }
}

// Running the program spawns a single actor on UDP port 3000. Messages are JSON-serialized.
fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000), ActorContext)
        ]).unwrap();
}

</code></pre>
<h2><a class="header" href="#implementation-walkthrough-1" id="implementation-walkthrough-1">Implementation Walkthrough</a></h2>
<p>Addressing the linearizability issue is merely a matter of throwing away
message redeliveries. The simplest approach is to record every delivered request ID.</p>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Hash, PartialEq)]
struct ActorState {
    value: char,
    delivered: BTreeSet&lt;(Id, RequestId)&gt;,
}

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = ActorState;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        ActorState {
            value: '?',
            delivered: Default::default(),
        }
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, state.value));
            }
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>With that small change, each server provides an independent linearizable
register. In the presence of messages concurrently in flight, the register
abstraction is still
<a href="https://en.wikipedia.org/wiki/Linearizability">linearizable</a> (for example,
reads cannot observe values overwritten before the read began, among other
characteristics).</p>
<p>The servers feature no replication, so a <em>collection</em> of servers does not provide
a unified service that emulates a linearizable register as the servers will not
generally agree upon the last value they received.</p>
<pre><code class="language-rust ignore noplayground">    #[test]
    fn satisfies_all_properties() {
        // Works with 1 client.
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        checker.assert_properties();

        // Or with multiple clients.
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 2, // TIP: test with `--release` mode for more clients
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        checker.assert_properties();
    }

    #[test]
    fn not_linearizable_with_two_servers() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext, ActorContext], // two servers
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Put(2, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(2), msg: PutOk(2) },
            Deliver { src: Id::from(2), dst: Id::from(1), msg: Put(4, 'Z') },
            Deliver { src: Id::from(1), dst: Id::from(2), msg: PutOk(4) },
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Get(6) },
            Deliver { src: Id::from(0), dst: Id::from(2), msg: GetOk(6, 'A') },
        ]);
    }
</code></pre>
<h2><a class="header" href="#suggested-exercises" id="suggested-exercises">Suggested Exercises</a></h2>
<ol>
<li><strong>Compaction</strong>: Storing every request ID isn't viable for a long running
process.  The simplest approach is to require that request IDs are
&quot;monotonic&quot; -- which means they are increasing (and gaps are acceptable). In
that case, the delivery handler throws away messages with a request ID
smaller than the last handled message. See if you can amend the example
accordingly.</li>
<li><strong>Optimized Compaction</strong>: Reordered messages will be dropped because late
delivered message will have a smaller request ID. Protocols need to account
for the network dropping messages anyway, so generally speaking this
tradeoff only impacts performance. Still, throughput can be improved by
adding a &quot;sliding window&quot; buffer on the server side to minimize dropped
messages. See if you can implement that.</li>
<li><strong>Lossless Link</strong>: One technique for minimizing message loss is to have
the client also maintain a buffer of outgoing messages, and the client
periodically resends messages that have not been acknowledged by the
recipient within a particular timeout period. TCP for example does this for
packets. See if you can implement this as well. If you need help, see
<a href="https://github.com/stateright/stateright/blob/master/src/actor/ordered_reliable_link.rs"><code>ordered_reliable_link.rs</code></a> in the Stateright repository.</li>
</ol>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>This chapter showed how to fix the implementation from the previous chapter,
maintaining linearizability even if messages are redelivered. The next chapter
<a href="./seeking-consensus.html">Seeking Consensus</a> will introduce the concept of
replication, which is used to provide (1) data recoverability in the event of a
server crash and/or (2) improved performance for high request rates by
distributing requests (such as reads) across a wider range of hosts.</p>
<h1><a class="header" href="#chapter-3-seeking-consensus" id="chapter-3-seeking-consensus">Chapter 3: Seeking Consensus</a></h1>
<p>In the last chapter we fixed a bug caused by the network's susceptibility to
message redelivery, but our solution could only run on a single server.
Introducing a second server would break linearizability as the system failed to
replicate information between servers.</p>
<p>In this chapter we introduce a simple replication protocol in an attempt to
address that shortcoming.</p>
<p>Once again, we start by initializing a new Rust project:</p>
<pre><code class="language-sh">mkdir seeking-consensus
cd seeking-consensus
cargo init
</code></pre>
<p>Next we add dependencies to <code>Cargo.toml</code>. Notice that we now need to include
the <code>serde</code> package.</p>
<pre><code class="language-toml">[package]
name = &quot;seeking-consensus&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
env_logger = &quot;0.7&quot;
serde = &quot;1.0&quot;
serde_json = &quot;1.0&quot;
stateright = &quot;0.23&quot;
</code></pre>
<p>By now you have the hang of implementing basic actor systems in Stateright, so
we'll defer the full <code>main.rs</code> source code listing until later in the chapter.</p>
<h2><a class="header" href="#a-replication-protocol" id="a-replication-protocol">A Replication Protocol</a></h2>
<p>First we get to decide on a replication protocol. Give this some thought, and
see if you have ideas.</p>
<blockquote>
<p><strong>Exercise</strong>: Yes, really. Take some time to think about how you might add
replication.</p>
</blockquote>
<p>Done? Great!</p>
<p>For this example, we'll proceed with a protocol that simply involves forwarding
the value to every peer server before replying to the client, thereby ensuring
the servers agree on the value. This might be the protocol that you envisioned
as well.</p>
<h2><a class="header" href="#implementation-walkthrough-2" id="implementation-walkthrough-2">Implementation Walkthrough</a></h2>
<p>The first notable difference is the need to introduce a message type for
replication.</p>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Hash, Eq, PartialEq)]
#[derive(Deserialize, Serialize)]
enum InternalMsg {
    Replicate(RequestId, char),
    ReplicateOk(RequestId),
}
</code></pre>
<p>The server defers sending a <code>PutOk</code> message until replicas reply, but
Stateright actors are nonblocking, so they must manage some additional state:</p>
<ul>
<li>the ID of the request, against which replica replies are matched (to guard
against late responses),</li>
<li>the ID of the client that made the request (to facilitate replying later),</li>
<li>and the set of servers that have acknowledged the replicated value (to
facilitate waiting until all have replied).</li>
</ul>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Hash, PartialEq)]
struct ActorState {
    value: char,
    delivered: BTreeSet&lt;(Id, RequestId)&gt;,
    in_flight_put: Option&lt;PutState&gt;,
}

#[derive(Clone, Debug, Hash, PartialEq)]
struct PutState {
    req_id: RequestId,
    src: Id,
    peer_acks: BTreeSet&lt;Id&gt;,
}
</code></pre>
<p>We are now ready to implement the protocol.</p>
<pre><code class="language-rust ignore noplayground">    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) if state.in_flight_put.is_none() =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                state.in_flight_put = Some(PutState {
                    req_id,
                    src,
                    peer_acks: Default::default(),
                });
                for &amp;peer_id in &amp;self.peer_ids {
                    o.send(peer_id,
                           RegisterMsg::Internal(
                               InternalMsg::Replicate(req_id, value)));
                }
                // Will not reply w/ `PutOk` until all replicas ack.
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, state.value));
            }
            RegisterMsg::Internal(InternalMsg::Replicate(req_id, value)) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                o.send(src,
                       RegisterMsg::Internal(InternalMsg::ReplicateOk(req_id)));
            }
            RegisterMsg::Internal(InternalMsg::ReplicateOk(req_id)) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                if let Some(put) = &amp;mut state.in_flight_put {
                    if req_id != put.req_id { return }

                    put.peer_acks.insert(src);
                    if put.peer_acks == self.peer_ids {
                        o.send(put.src, RegisterMsg::PutOk(req_id));
                        state.in_flight_put = None;
                    }
                }
            }
            _ =&gt; {}
        }
    }
</code></pre>
<p>Now the big question: does this protocol solve the problem we ran
into last chapter?</p>
<p>Unfortunately achieving linearizability involves a bit more sophistication, and
Stateright identifies a sequence of steps that are not linearizable. The
sequence is nontrivial and demonstrates why a model checker is so useful for
implementing distributed systems.</p>
<pre><code class="language-rust ignore noplayground">        // Fails if there are 3 clients.
        let checker = RegisterTestSystem {
            servers: vec![
                ActorContext { peer_ids: vec![Id::from(1)].into_iter().collect() },
                ActorContext { peer_ids: vec![Id::from(0)].into_iter().collect() },
            ],
            client_count: 3,
            .. Default::default()
        }.into_model().checker()
        .spawn_dfs().join();     // TRY IT: Comment out this line, and uncomment
        //.serve(&quot;0:3000&quot;);      //         the next to load Stateright Explorer.
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(4), dst: Id::from(0), msg: Put(4, 'C') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: Internal(Replicate(4, 'C')) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Internal(ReplicateOk(4)) },
            Deliver { src: Id::from(3), dst: Id::from(1), msg: Put(3, 'B') },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Internal(Replicate(3, 'B')) },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: Internal(ReplicateOk(3)) },
            Deliver { src: Id::from(1), dst: Id::from(3), msg: PutOk(3) },
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Put(2, 'A') },
            Deliver { src: Id::from(3), dst: Id::from(0), msg: Get(6) },
            Deliver { src: Id::from(0), dst: Id::from(3), msg: GetOk(6, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(4), msg: PutOk(4) },
            Deliver { src: Id::from(4), dst: Id::from(1), msg: Get(8) },
            Deliver { src: Id::from(1), dst: Id::from(4), msg: GetOk(8, 'B') },
        ]);
</code></pre>
<h2><a class="header" href="#stateright-explorer" id="stateright-explorer">Stateright Explorer</a></h2>
<p>It's not immediately clear why the sequence of steps identified by Stateright
violates linearizability. Luckily Stateright includes a web UI that can help
you understand scenarios such as this one.</p>
<p>Stateright Explorer is started by calling
<a href="https://docs.rs/stateright/latest/stateright/struct.CheckerBuilder.html#method.serve"><code>serve(...)</code></a>.
You can easily do this by following the directions in the first <code>// TRY IT</code> line,
which will suspend the test when it is next run, allowing you to load
<code>http://localhost:3000</code> in your web browser to debug.</p>
<blockquote>
<p><strong>Tip</strong>: Model checking with Stateright Explorer is breadth-first, as that
tends to find shorter discovery paths than depth-first search. One downside of
this approach is that breadth-first search consumes more memory, so Explorer
works best with relatively small state spaces (hundreds of thousands of states
rather than millions of states, for example).</p>
</blockquote>
<p>When you load Stateright Explorer, you'll see the checker status in the upper
left corner. Within a few seconds the checker should add <code>&quot;linearizable&quot; counterexample</code> to its list of discoveries.</p>
<p><img src="seeking-consensus.explorer.png" alt="Stateright Explorer on load" /></p>
<p>Click that link to load the discovery.</p>
<p><img src="seeking-consensus.explorer2.png" alt="Stateright Explorer after clicking the link" /></p>
<p>The first thing you might notice is the
sequence diagram.</p>
<p><img src="seeking-consensus.sequence.png" alt="sequence diagram for the linearizability violation" /></p>
<p>Tracing backwards from the last event, we can see why linearizability is
violated:</p>
<ol>
<li><code>GetOk(8, 'B')</code> indicates that <code>'B'</code> is the earliest write finishing before
the read. Also, no operations are concurrent with the read.</li>
<li><code>PutOk(4)</code> was in response to the long running <code>Put(4, 'C')</code> operation,
indicating that the value <code>'C'</code> must have been written at some point between
invocation and response. Unlike the read, the precise sequencing of this
write in relation to other operations is indeterminate due to concurrency).</li>
<li><code>GetOk(6, 'A')</code> indicates that <code>'A'</code> is the earliest write finishing before
that read. Only the write of <code>'C'</code> is concurrent with the start and end of
the read, so it's possible that the write took effect before or after the
read took effect.</li>
</ol>
<p>We don't have to trace any further back, as those observations above highlight
the anomaly: <code>'A'</code> had been the most recent write, then <code>'C'</code> may or may not
have been written next (as the concurrency allows different linearizations),
and finally <code>'B'</code> was read. No linearization of concurrent operations can
reconcile this anomaly, so the protocol is not linearizable. QED.</p>
<h2><a class="header" href="#complete-implementation" id="complete-implementation">Complete Implementation</a></h2>
<p>Here is the complete implementation for <code>main.rs</code>:</p>
<pre><code class="language-rust ignore noplayground">
use serde::{Deserialize, Serialize};
use stateright::actor::{*, register::*};
use std::borrow::Cow;
use std::collections::BTreeSet;
use std::net::{SocketAddrV4, Ipv4Addr};

type RequestId = u64;

#[derive(Clone)]
struct ActorContext {
    peer_ids: BTreeSet&lt;Id&gt;,
}

#[derive(Clone, Debug, Hash, Eq, PartialEq)]
#[derive(Deserialize, Serialize)]
enum InternalMsg {
    Replicate(RequestId, char),
    ReplicateOk(RequestId),
}

#[derive(Clone, Debug, Hash, PartialEq)]
struct ActorState {
    value: char,
    delivered: BTreeSet&lt;(Id, RequestId)&gt;,
    in_flight_put: Option&lt;PutState&gt;,
}

#[derive(Clone, Debug, Hash, PartialEq)]
struct PutState {
    req_id: RequestId,
    src: Id,
    peer_acks: BTreeSet&lt;Id&gt;,
}

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, InternalMsg&gt;;
    type State = ActorState;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        ActorState {
            value: '?',
            delivered: Default::default(),
            in_flight_put: None,
        }
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) if state.in_flight_put.is_none() =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                state.in_flight_put = Some(PutState {
                    req_id,
                    src,
                    peer_acks: Default::default(),
                });
                for &amp;peer_id in &amp;self.peer_ids {
                    o.send(peer_id,
                           RegisterMsg::Internal(
                               InternalMsg::Replicate(req_id, value)));
                }
                // Will not reply w/ `PutOk` until all replicas ack.
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, state.value));
            }
            RegisterMsg::Internal(InternalMsg::Replicate(req_id, value)) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                o.send(src,
                       RegisterMsg::Internal(InternalMsg::ReplicateOk(req_id)));
            }
            RegisterMsg::Internal(InternalMsg::ReplicateOk(req_id)) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                if let Some(put) = &amp;mut state.in_flight_put {
                    if req_id != put.req_id { return }

                    put.peer_acks.insert(src);
                    if put.peer_acks == self.peer_ids {
                        o.send(put.src, RegisterMsg::PutOk(req_id));
                        state.in_flight_put = None;
                    }
                }
            }
            _ =&gt; {}
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use stateright::*;
    use InternalMsg::{Replicate, ReplicateOk};
    use RegisterMsg::{Get, GetOk, Internal, Put, PutOk};
    use SystemAction::Deliver;

    #[test]
    fn appears_linearizable_in_limited_scenarios() {
        // Succeeds if there are 2 clients.
        let checker = RegisterTestSystem {
            servers: vec![
                ActorContext { peer_ids: vec![Id::from(1)].into_iter().collect() },
                ActorContext { peer_ids: vec![Id::from(0)].into_iter().collect() },
            ],
            client_count: 2,
            .. Default::default()
        }.into_model().checker().spawn_bfs().join();
        checker.assert_properties();
    }

    #[test]
    fn not_generally_linearizable() {
        // Fails if there are 3 clients.
        let checker = RegisterTestSystem {
            servers: vec![
                ActorContext { peer_ids: vec![Id::from(1)].into_iter().collect() },
                ActorContext { peer_ids: vec![Id::from(0)].into_iter().collect() },
            ],
            client_count: 3,
            .. Default::default()
        }.into_model().checker()
        .spawn_dfs().join();     // TRY IT: Comment out this line, and uncomment
        //.serve(&quot;0:3000&quot;);      //         the next to load Stateright Explorer.
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(4), dst: Id::from(0), msg: Put(4, 'C') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: Internal(Replicate(4, 'C')) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Internal(ReplicateOk(4)) },
            Deliver { src: Id::from(3), dst: Id::from(1), msg: Put(3, 'B') },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Internal(Replicate(3, 'B')) },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: Internal(ReplicateOk(3)) },
            Deliver { src: Id::from(1), dst: Id::from(3), msg: PutOk(3) },
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Put(2, 'A') },
            Deliver { src: Id::from(3), dst: Id::from(0), msg: Get(6) },
            Deliver { src: Id::from(0), dst: Id::from(3), msg: GetOk(6, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(4), msg: PutOk(4) },
            Deliver { src: Id::from(4), dst: Id::from(1), msg: Get(8) },
            Deliver { src: Id::from(1), dst: Id::from(4), msg: GetOk(8, 'B') },
        ]);
    }
}

// Running the program spawns actors on UDP ports 3000-3002. Messages are JSON-serialized.
fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    let id0 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000));
    let id1 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3001));
    let id2 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3002));
    spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (id0, ActorContext { peer_ids: vec![id1, id2].into_iter().collect() } ),
            (id1, ActorContext { peer_ids: vec![id0, id2].into_iter().collect() } ),
            (id2, ActorContext { peer_ids: vec![id0, id1].into_iter().collect() } ),
        ]).unwrap();
}

</code></pre>
<h2><a class="header" href="#suggested-exercise" id="suggested-exercise">Suggested Exercise</a></h2>
<p>Uncomment the second <code>// TRY IT</code> line to cause the test to fail, delete the
linearizability counterexample assertion since it may not longer apply, and see
if you can amend the actor implementation to make the test pass. The next
chapter will provide a solution, but going through the exercise of trying to
design a solution youself will help convey how subtle bugs can be with
distributed protocols, and hopefully it will demonstrate why Stateright is so
useful for this problem space.</p>
<blockquote>
<p><strong>Reminder</strong>: use <code>cargo test --release</code> when running the tests for
dramatically better model checking performance. Running tests without that flag
may result in significant delays. Also, try using <a href="https://docs.rs/stateright/latest/stateright/struct.CheckerBuilder.html#method.serve">Stateright
Explorer</a>
for debugging as needed.</p>
</blockquote>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<p>This chapter introduced replication, and Stateright was able to find a bug in
our replication protocol. The next chapter, <a href="./achieving-linearizability.html"><code>Achieving Linearizability</code></a> introduces a more
sophisticated protocol that makes the replicated register linearizable.</p>
<h1><a class="header" href="#chapter-4-achieving-linearizability" id="chapter-4-achieving-linearizability">Chapter 4: Achieving Linearizability</a></h1>
<p>In the last chapter we implemented a faulty replication protocol that violated
linearizability because the emulated register was not atomic. This chapter
introduces a more sophisticated replication protocol that the author first
learned about when reading the blog post &quot;<a href="https://muratbuffalo.blogspot.com/2012/05/replicatedfault-tolerant-atomic-storage.html">Replicated/Fault-tolerant atomic
storage</a>&quot;
by Murat Demirbas.</p>
<p>As usual, we start by initializing a new Rust project:</p>
<pre><code class="language-sh">mkdir achieving-linearizability
cd achieving-linearizability
cargo init
</code></pre>
<p>Then we define dependencies.</p>
<pre><code class="language-toml">[package]
name = &quot;achieving-linearizability&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
env_logger = &quot;0.7&quot;
serde = &quot;1.0&quot;
serde_json = &quot;1.0&quot;
stateright = &quot;0.23&quot;
</code></pre>
<h2><a class="header" href="#a-truly-atomic-register" id="a-truly-atomic-register">A Truly Atomic Register</a></h2>
<p>One problem with the earlier protocol is that reads can observe different
values depending on which server accepts the read. We need to amend the
protocol to ensure that given the same aggregate system state, any two reads
are guaranteed to observe the same value. The simplest solution is to query
every server when servicing a read operation, but that introduces yet another
problem: availability. By forcing reads to query every server, if a single
server becomes unavailable, the entire system becomes unavailable. This problem
also exists for writes in that replication protocol.</p>
<p>The trick to solving this new problem is observing that we only need to ensure
that &quot;read sets&quot; overlap one another. If a majority of servers agree on a
value, then we know that any other majority of servers must either agree on the
same value or must have a different value that is not part of the majority.  We
can apply the same logic to the &quot;write set&quot; as well.  We call the set of
sufficient reads a &quot;read quorum&quot; and the set of sufficient writes a &quot;write
quorum.&quot;</p>
<p>Leveraging read and write quorums solves the availability problem when a
minority of servers are unreachable, but we still have a second availability
problem: in many cases a read set will not agree on a value. This can happen if
the read is concurrent with a write or if two earlier writes were concurrent.
In those cases, the server accepting the read must either ignore the request or
return an error, upon which we can improve.</p>
<p>To solve this remaining problem, we simply need to force the system into
agreement, thereby ensuring any subsequent read either observes the forced
agreement or a subsequent write. This is the technique employed by Attiya,
Bar-Noy, and Dolev in their paper &quot;<a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.96.5395">Sharing Memory Robustly in Message-Passing
Systems</a>&quot;.</p>
<p>Both read and write operations are handled in two phases: (1) a <strong>query</strong> phase
followed by (2) a <strong>replication</strong> phase.</p>
<ul>
<li><strong>1. Query Phase</strong>: In the query phase, a server finds out what replicated
values a quorum of replicas has previously accepted. The replicas also
return a <a href="https://en.wikipedia.org/wiki/Logical_clock">logical clock</a> that
serves to sequence earlier write operations, so the implementation will refer
to this as a <em>sequencer</em>.</li>
<li><strong>2a. Write Replication Phase</strong>: If servicing a write, then upon receiving
responses from a quorum, the server replicates the chosen value along with a
slightly larger sequencer than the one observed. Once a majority of the
replicas ack this second phase, the server can indicate to the client that
the write is complete.</li>
<li><strong>2b. Read Replication Phase</strong>: If servicing a read, then upon receiving
responses from a quorum, the server replicates the value with the largest
observed sequencer. Once a majority of the replicas ack this second phase,
the server can return the value that it replicated.</li>
</ul>
<h2><a class="header" href="#implementation-walkthrough-3" id="implementation-walkthrough-3">Implementation Walkthrough</a></h2>
<p>We first define our message type. <code>Abd...</code> in the type refers to the names of
the algorithm's original author's -- Attiya, Bar-Noy, and Dolev -- or &quot;ABD.&quot;</p>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[derive(Serialize, Deserialize)]
enum AbdMsg {
    Query(TestRequestId),
    AckQuery(TestRequestId, Seq, TestValue),
    Replicate(TestRequestId, Seq, TestValue),
    AckReplicate(TestRequestId),
}
</code></pre>
<p>The current implementation combines the roles of &quot;replica&quot; and &quot;coordinator
that accepts a request and facilitates replication.&quot; <code>seq</code> and <code>val</code> are for
the first role, while <code>phase</code> tracks information needed by the second role.</p>
<p>Of particular note is that for phase 1, writes need to remember what value to
later replicate, which is stored in <code>write</code>. Conversely for phase 2, reads need
to remember what value to later return to the client, which is stored in
<code>read</code>.</p>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Eq, Hash, PartialEq)]
struct AbdState {
    seq: Seq,
    val: TestValue,
    phase: Option&lt;AbdPhase&gt;,
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
enum AbdPhase {
    Phase1 {
        request_id: TestRequestId,
        requester_id: Id,
        write: Option&lt;TestValue&gt;, // `None` for read
        responses: HashableHashMap&lt;Id, (Seq, TestValue)&gt;,
    },
    Phase2 {
        request_id: TestRequestId,
        requester_id: Id,
        read: Option&lt;TestValue&gt;, // `None` for write
        acks: HashableHashSet&lt;Id&gt;,
    },
}

type Seq = (WriteCount, Id); // `Id` for uniqueness
type WriteCount = u64;
</code></pre>
<p>We are now ready to implement the protocol. Note that the implementation
intentionally avoids decomposing the message handlers into different function
calls because each call needs to manage shared actor state. Spreading state
mutation across multiple locations in the source code arguably makes the
implementation harder to follow (much like mutable global variables), and
functions are only used where they can be reasoned about locally.</p>
<p>An alternative composition strategy that does often work well for actor systems
involves distinguishing roles so that each has less state (having different
<code>AbdServer</code> and <code>AbdReplica</code> actors for example), although we will not do that
for this short example. The next chapter on the other hand will demonstrate how
to compose a system of different actor types.</p>
<pre><code class="language-rust ignore noplayground">#[derive(Clone)]
struct AbdActor {
    peers: Vec&lt;Id&gt;,
}

impl Actor for AbdActor {
    type Msg = RegisterMsg&lt;TestRequestId, TestValue, AbdMsg&gt;;
    type State = AbdState;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        AbdState {
            seq: (0, Id::from(0)),
            val: '?',
            phase: None,
        }
    }

    fn on_msg(&amp;self, id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        use RegisterMsg::*;
        match msg {
            Put(req_id, val) if state.phase.is_none() =&gt; {
                o.broadcast(&amp;self.peers, &amp;Internal(Query(req_id)));
                state.to_mut().phase = Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: src,
                    write: Some(val),
                    responses: {
                        let mut responses = HashableHashMap::default();
                        responses.insert(id, (state.seq, state.val.clone()));
                        responses
                    },
                });
            }
            Get(req_id) if state.phase.is_none() =&gt; {
                o.broadcast(&amp;self.peers, &amp;Internal(Query(req_id)));
                state.to_mut().phase = Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: src,
                    write: None,
                    responses: {
                        let mut responses = HashableHashMap::default();
                        responses.insert(id, (state.seq, state.val.clone()));
                        responses
                    },
                });
            }
            Internal(Query(req_id)) =&gt; {
                o.send(
                    src,
                    Internal(AckQuery(req_id, state.seq, state.val.clone())));
            }
            Internal(AckQuery(expected_req_id, seq, val))
                if matches!(state.phase,
                            Some(AbdPhase::Phase1 { request_id, .. })
                            if request_id == expected_req_id) =&gt;
            {
                let mut state = state.to_mut();
                if let Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: requester,
                    write,
                    responses,
                    ..
                }) = &amp;mut state.phase {
                    responses.insert(src, (seq, val));
                    if responses.len() == majority(self.peers.len() + 1) {
                        // Quorum reached. Move to phase 2.

                        // Determine sequencer and value.
                        let (_, (seq, val)) = responses.into_iter()
                            .max_by_key(|(_, (seq, _))| seq)
                            .unwrap();
                        let mut seq = *seq;
                        let mut read = None;
                        let val = if let Some(val) = std::mem::take(write) {
                            seq = (seq.0 + 1, id);
                            val
                        } else {
                            read = Some(val.clone());
                            val.clone()
                        };

                        o.broadcast(
                            &amp;self.peers,
                            &amp;Internal(Replicate(*req_id, seq, val.clone())));

                        state.seq = seq;
                        state.val = val;

                        let mut acks = HashableHashSet::default();
                        acks.insert(id);

                        state.phase = Some(AbdPhase::Phase2 {
                            request_id: *req_id,
                            requester_id: std::mem::take(requester),
                            read,
                            acks,
                        });
                    }
                }
            }
            Internal(Replicate(req_id, seq, val)) =&gt; {
                o.send(src, Internal(AckReplicate(req_id)));
                if seq &gt; state.seq {
                    let mut state = state.to_mut();
                    state.seq = seq;
                    state.val = val;
                }
            }
            Internal(AckReplicate(expected_req_id))
                if matches!(state.phase,
                            Some(AbdPhase::Phase2 { request_id, .. })
                            if request_id == expected_req_id) =&gt;
            {
                let mut state = state.to_mut();
                if let Some(AbdPhase::Phase2 {
                    request_id: req_id,
                    requester_id: requester,
                    read,
                    acks,
                    ..
                }) = &amp;mut state.phase {
                    acks.insert(src);
                    if acks.len() == majority(self.peers.len() + 1) {
                        let msg = if let Some(val) = read {
                            GetOk(*req_id, std::mem::take(val))
                        } else {
                            PutOk(*req_id)
                        };
                        o.send(*requester, msg);
                        state.phase = None;
                    }
                }
            }
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>The test case confirms that this implementation is linearizable. Remember to
run the tests with the <code>--release</code> flag if you want to check with a larger
number of clients or servers, as the state space grows rapidly.</p>
<pre><code class="language-rust ignore noplayground">    let checker = RegisterTestSystem {
        servers: vec![
            AbdActor { peers: model_peers(0, 2) },
            AbdActor { peers: model_peers(1, 2) },
        ],
        client_count: 2,
        within_boundary: |state| {
            state.actor_states.iter().all(|s| {
                if let RegisterActorState::Server(s) = &amp;**s {
                    s.seq.0 &lt;= 3
                } else {
                    true
                }
            })
        },
        duplicating_network: DuplicatingNetwork::No,
        .. Default::default()
    }.into_model().checker()
    .spawn_dfs().join();
    checker.assert_properties();
</code></pre>
<h2><a class="header" href="#complete-implementation-1" id="complete-implementation-1">Complete Implementation</a></h2>
<p>Here is the complete implementation for <code>main.rs</code>:</p>
<pre><code class="language-rust ignore noplayground">use serde::{Deserialize, Serialize};
use stateright::actor::{*, register::*};
use stateright::util::{HashableHashMap, HashableHashSet};
use std::borrow::Cow;
use std::fmt::Debug;
use std::hash::Hash;
use std::net::{SocketAddrV4, Ipv4Addr};

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[derive(Serialize, Deserialize)]
enum AbdMsg {
    Query(TestRequestId),
    AckQuery(TestRequestId, Seq, TestValue),
    Replicate(TestRequestId, Seq, TestValue),
    AckReplicate(TestRequestId),
}
use AbdMsg::*;

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
struct AbdState {
    seq: Seq,
    val: TestValue,
    phase: Option&lt;AbdPhase&gt;,
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
enum AbdPhase {
    Phase1 {
        request_id: TestRequestId,
        requester_id: Id,
        write: Option&lt;TestValue&gt;, // `None` for read
        responses: HashableHashMap&lt;Id, (Seq, TestValue)&gt;,
    },
    Phase2 {
        request_id: TestRequestId,
        requester_id: Id,
        read: Option&lt;TestValue&gt;, // `None` for write
        acks: HashableHashSet&lt;Id&gt;,
    },
}

type Seq = (WriteCount, Id); // `Id` for uniqueness
type WriteCount = u64;

#[derive(Clone)]
struct AbdActor {
    peers: Vec&lt;Id&gt;,
}

impl Actor for AbdActor {
    type Msg = RegisterMsg&lt;TestRequestId, TestValue, AbdMsg&gt;;
    type State = AbdState;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        AbdState {
            seq: (0, Id::from(0)),
            val: '?',
            phase: None,
        }
    }

    fn on_msg(&amp;self, id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        use RegisterMsg::*;
        match msg {
            Put(req_id, val) if state.phase.is_none() =&gt; {
                o.broadcast(&amp;self.peers, &amp;Internal(Query(req_id)));
                state.to_mut().phase = Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: src,
                    write: Some(val),
                    responses: {
                        let mut responses = HashableHashMap::default();
                        responses.insert(id, (state.seq, state.val.clone()));
                        responses
                    },
                });
            }
            Get(req_id) if state.phase.is_none() =&gt; {
                o.broadcast(&amp;self.peers, &amp;Internal(Query(req_id)));
                state.to_mut().phase = Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: src,
                    write: None,
                    responses: {
                        let mut responses = HashableHashMap::default();
                        responses.insert(id, (state.seq, state.val.clone()));
                        responses
                    },
                });
            }
            Internal(Query(req_id)) =&gt; {
                o.send(
                    src,
                    Internal(AckQuery(req_id, state.seq, state.val.clone())));
            }
            Internal(AckQuery(expected_req_id, seq, val))
                if matches!(state.phase,
                            Some(AbdPhase::Phase1 { request_id, .. })
                            if request_id == expected_req_id) =&gt;
            {
                let mut state = state.to_mut();
                if let Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: requester,
                    write,
                    responses,
                    ..
                }) = &amp;mut state.phase {
                    responses.insert(src, (seq, val));
                    if responses.len() == majority(self.peers.len() + 1) {
                        // Quorum reached. Move to phase 2.

                        // Determine sequencer and value.
                        let (_, (seq, val)) = responses.into_iter()
                            .max_by_key(|(_, (seq, _))| seq)
                            .unwrap();
                        let mut seq = *seq;
                        let mut read = None;
                        let val = if let Some(val) = std::mem::take(write) {
                            seq = (seq.0 + 1, id);
                            val
                        } else {
                            read = Some(val.clone());
                            val.clone()
                        };

                        o.broadcast(
                            &amp;self.peers,
                            &amp;Internal(Replicate(*req_id, seq, val.clone())));

                        state.seq = seq;
                        state.val = val;

                        let mut acks = HashableHashSet::default();
                        acks.insert(id);

                        state.phase = Some(AbdPhase::Phase2 {
                            request_id: *req_id,
                            requester_id: std::mem::take(requester),
                            read,
                            acks,
                        });
                    }
                }
            }
            Internal(Replicate(req_id, seq, val)) =&gt; {
                o.send(src, Internal(AckReplicate(req_id)));
                if seq &gt; state.seq {
                    let mut state = state.to_mut();
                    state.seq = seq;
                    state.val = val;
                }
            }
            Internal(AckReplicate(expected_req_id))
                if matches!(state.phase,
                            Some(AbdPhase::Phase2 { request_id, .. })
                            if request_id == expected_req_id) =&gt;
            {
                let mut state = state.to_mut();
                if let Some(AbdPhase::Phase2 {
                    request_id: req_id,
                    requester_id: requester,
                    read,
                    acks,
                    ..
                }) = &amp;mut state.phase {
                    acks.insert(src);
                    if acks.len() == majority(self.peers.len() + 1) {
                        let msg = if let Some(val) = read {
                            GetOk(*req_id, std::mem::take(val))
                        } else {
                            PutOk(*req_id)
                        };
                        o.send(*requester, msg);
                        state.phase = None;
                    }
                }
            }
            _ =&gt; {}
        }
    }
}

#[cfg(test)]
#[test]
fn is_linearizable() {
    use stateright::{Checker, Model};

    let checker = RegisterTestSystem {
        servers: vec![
            AbdActor { peers: model_peers(0, 2) },
            AbdActor { peers: model_peers(1, 2) },
        ],
        client_count: 2,
        within_boundary: |state| {
            state.actor_states.iter().all(|s| {
                if let RegisterActorState::Server(s) = &amp;**s {
                    s.seq.0 &lt;= 3
                } else {
                    true
                }
            })
        },
        duplicating_network: DuplicatingNetwork::No,
        .. Default::default()
    }.into_model().checker()
    .spawn_dfs().join();
    checker.assert_properties();
}

fn main() {
    env_logger::init_from_env(
        env_logger::Env::default().default_filter_or(&quot;info&quot;));
    let id0 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000));
    let id1 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3001));
    let id2 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3002));
    spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (id0, AbdActor { peers: vec![id1, id2] }),
            (id1, AbdActor { peers: vec![id0, id2] }),
            (id2, AbdActor { peers: vec![id0, id1] }),
        ]).unwrap();
}
</code></pre>
<h2><a class="header" href="#suggested-exercises-1" id="suggested-exercises-1">Suggested Exercises</a></h2>
<ol>
<li>
<p>This algorithm can be optimized by observing that the replication phases
need not replicate values if the quorum already agrees on a value. See if
you can implement this optimization.</p>
</li>
<li>
<p>More generally, replication messages only need to be sent to replicas that
disagree. See if you can implement this optimization as well.</p>
<blockquote>
<p>TIP: This is a slightly more complex optimization because we need to treat
&quot;all agree&quot; versus &quot;not all agree&quot; slightly differently to avoid dropping
requests in some cases. Can you see why?</p>
</blockquote>
</li>
</ol>
<h2><a class="header" href="#summary-3" id="summary-3">Summary</a></h2>
<p>This chapter provided the first taste of a real distributed algorithm. We were
able to incrementally infer a solution, but it was nontrivial. If there
were bugs in the code, they could be relatively difficult to identify without a
model checker.</p>
<p>In the next chapter, we will introduce the notion of &quot;consensus&quot; and implement
it via the Multi-Paxos algorithm. That chapter is not yet available, so in the
meantime you can learn more about Stateright by browsing additional <a href="https://github.com/stateright/stateright/tree/master/examples">Stateright
examples</a> and
reviewing the <a href="https://docs.rs/stateright">Stateright API docs</a>. If you are
familiar with TLA+, then the subsequent chapter <a href="./comparison-with-tlaplus.html">Comparison with
TLA+</a> may also be interesting to you.</p>
<p>If you have any questions, comments, or ideas, please share them on
<a href="https://discord.com/channels/781357978652901386">Stateright's Discord server</a>.
At this time Stateright is a small personal project, and the main author is
eager to hear community feedback.</p>
<h1><a class="header" href="#comparison-with-tla" id="comparison-with-tla">Comparison with TLA+</a></h1>
<p>The previous part of this book focused on model checking runnable actor
systems.  Stateright is also able to model check higher level designs via
&quot;abstract models,&quot; much like a traditional model checker. This chapter compares
two abstract models of the <a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">two-phase commit
protocol</a>: one written
in a language called <a href="https://en.wikipedia.org/wiki/TLA%2B">TLA+</a> and the other
written in Rust. The chapter exists to assist those who are already familiar
with TLA+, so feel free to skip if you are not familiar with TLA+.</p>
<h2><a class="header" href="#attribution" id="attribution">Attribution</a></h2>
<p>The TLA+ model comes from the paper &quot;<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2003-96.pdf">Consensus on transaction
commit</a>&quot;
by Jim Gray and Leslie Lamport and is used in accordance with the ACM's
<a href="https://www.acm.org/publications/policies/software-copyright-notice">Software Copyright
Notice</a>.
It has been adapted slightly for this book. Here are the copyright details from
the paper:</p>
<blockquote>
<p>Copyright 2005 by the Association for Computing Machinery, Inc. Permission
to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or
distributed for profit or  commercial  advantage and  that  copies  bear this
notice  and  the  full  citation on the first page.  Copyrights for components
of this work owned by others than ACM must be honored.  Abstracting with credit
is permitted.  To copy otherwise, to republish, to post on servers, or to
redistribute to lists, requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM Inc., fax +1 (212) 869-0481, or
<a href="mailto:permissions@acm.org">permissions@acm.org</a>.</p>
</blockquote>
<p>Citation:</p>
<blockquote>
<p>Jim Gray and Leslie Lamport. 2006. Consensus on transaction commit. ACM
Trans. Database Syst. 31, 1 (March 2006), 133–160.
DOI:<a href="https://doi.org/10.1145/1132863.1132867">https://doi.org/10.1145/1132863.1132867</a></p>
</blockquote>
<p><a href="https://lamport.azurewebsites.net/video/video6.html">Lecture 6</a> of Leslie
Lamport's <a href="https://lamport.azurewebsites.net/video/videos.html">TLA+ Video
Course</a> is recommended for
an additional overview of the specification.</p>
<h2><a class="header" href="#unique-benefits-of-each" id="unique-benefits-of-each">Unique Benefits of Each</a></h2>
<p>Before getting to the code, it is valuable to highlight that while the
functionality of TLC (the model checker for TLA+) and Stateright overlap to
some degree, each has unique benefits. Enumerating some of these can assist
with deciding when to use each solution.</p>
<p>Unique benefits of TLC/TLA+:</p>
<ul>
<li><strong>Brevity</strong>: TLA+ is more concise than Rust.</li>
<li><strong>State Reduction</strong>: TLC supports symmetry reduction.</li>
<li><strong>Features</strong>: TLC supports arbitrarily complex temporal properties including
fairness.</li>
<li><strong>Features</strong>: TLC supports refinement mapping between models.</li>
</ul>
<p>Unique benefits of Stateright/Rust:</p>
<ul>
<li><strong>Additional Verification</strong>: With Stateright your model and final
implementation are encouraged to share code. This eliminates a possible
failure mode whereby a model and it's resulting production system
implementation deviate.</li>
<li><strong>Reuse and Extensibility</strong>: Rust has a far larger library ecosystem and is
arguably more amenable to reuse than TLA+. For example, Stateright's code for
defining a system's <a href="https://docs.rs/stateright/latest/stateright/semantics/index.html">operational
semantics</a>
are not built into the model checker and could be provided as an external
library. The same can be said about the included <a href="https://docs.rs/stateright/latest/stateright/semantics/register/index.html">register
semantics</a>,
<a href="https://docs.rs/stateright/latest/stateright/semantics/struct.LinearizabilityTester.html">linearizability
tester</a>,
and <a href="https://docs.rs/stateright/latest/stateright/actor/index.html">actor
model</a> to name
a few other examples. More generally the entire <a href="https://crates.io/">Rust crate
registry</a> (with tens of thousands of libraries) is at
your disposal. In contrast, the pattern for reuse in TLA+ is
<a href="https://groups.google.com/g/tlaplus/c/BHBNTkJ2QFE/m/meTQs4pHBwAJ">copy-paste-modify</a>,
and the number of reusable modules is <a href="https://github.com/tlaplus/CommunityModules">relatively
small</a>.</li>
<li><strong>Checker Performance</strong>: Stateright tends to be faster and offers additional
optimization possibilities such as replacing a set with a bit vector for
example. While TLC allows you to <a href="https://stackoverflow.com/questions/53908653/use-module-overloading-to-implement-a-hash-function-in-tla">override modules with Java
implementations</a>,
doing so is relatively cumbersome and rarely used.</li>
<li><strong>Final Implementation Performance</strong>: As a more auxiliary benefit, Stateright
can serve as a stress test for your final implementation, identifying
regressions and also facilitating performance investigation.</li>
<li><strong>Features</strong>: Stateright offers
&quot;<a href="https://docs.rs/stateright/latest/stateright/struct.Property.html#method.sometimes">sometimes</a>&quot;
properties that serve to sanity check that expected outcomes are possible.
These are less powerful than temporal properties but serve a slightly
different purpose because examples of these properties being met are included
in the checker discoveries. You can simulate these in TLC by introducing
false &quot;invariants,&quot; but they need to be commented out and periodically run,
which is more cumbersome.</li>
<li><strong>Features</strong>: <a href="https://docs.rs/stateright/latest/stateright/struct.CheckerBuilder.html#method.serve">Stateright
Explorer</a>
allows you to interactively browse a model's state space and also lets you
jump between discoveries (whether they are property violations or instances
of &quot;sometimes&quot; properties).</li>
</ul>
<p>With those out of the way, let's move on to the code comparison.</p>
<h2><a class="header" href="#code-comparison" id="code-comparison">Code Comparison</a></h2>
<p>Both models are parameterized by a collection of &quot;resource managers.&quot; The TLA+
spec does not specify a type, but a set is expected. The Stateright spec maps
each resource manager to an integer in the range <code>0..N</code> (<code>0</code> to <code>N-1</code> inclusive).</p>
<table><tr><td>
<pre><code class="language-ignore noplayground">CONSTANT RM    
</code></pre>
</td><td>
<pre><code class="language-rust ignore noplayground">type R = usize; // RM in 0..N

#[derive(Clone)]
struct TwoPhaseSys { pub rms: Range&lt;R&gt; }
</code></pre>
</td></tr></table>
<p>Next we define variables. These are global in the TLA+ spec, and their type
constraints are indicated later in the spec via an invariant. In Stateright
these have a statically defined type.</p>
<table><tr><td>
<pre><code class="language-ignore noplayground">VARIABLES
  rmState,
  tmState,
  tmPrepared,
  msgs           
</code></pre>
</td><td>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Eq, Hash, PartialEq)]
struct TwoPhaseState {
    rm_state: Vec&lt;RmState&gt;,
    tm_state: TmState,
    tm_prepared: Vec&lt;bool&gt;,
    msgs: BTreeSet&lt;Message&gt;,
}
</code></pre>
</td></tr></table>
<p>Types in the TLA+ spec are conveyed via an invariant that is passed to its
model checker, TLC.</p>
<table><tr><td>
<pre><code class="language-ignore noplayground">Message ==
  [type : {&quot;Prepared&quot;}, rm : RM]  \cup  [type : {&quot;Commit&quot;, &quot;Abort&quot;}]
   
TypeOK ==  
  /\ rmState \in [RM -&gt; {&quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot;}]
  /\ tmState \in {&quot;init&quot;, &quot;committed&quot;, &quot;aborted&quot;}
  /\ tmPrepared \subseteq RM
  /\ msgs \subseteq Message
</code></pre>
</td><td>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
enum Message { Prepared { rm: R }, Commit, Abort }

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
enum RmState { Working, Prepared, Committed, Aborted }

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
enum TmState { Init, Committed, Aborted }
</code></pre>
</td></tr></table>
<p>TLA+ leverages temporal logic to convey the specification, while Stateright
requires that a trait is implemented. One other distinct aspect is that
Stateright actions are also types.</p>
<table><tr><td>
<pre><code class="language-ignore noplayground">Spec == Init
     /\ [][Next]_&lt;&lt;rmState, tmState, tmPrepared, msgs&gt;&gt;
</code></pre>
</td><td>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug)]
enum Action {
    TmRcvPrepared(R),
    TmCommit,
    TmAbort,
    RmPrepare(R),
    RmChooseToAbort(R),
    RmRcvCommitMsg(R),
    RmRcvAbortMsg(R),
}

impl Model for TwoPhaseSys {
    type State = TwoPhaseState;
    type Action = Action;
    ...
}
</code></pre>
</td></tr></table>
<p>The initial aggregate state is one where</p>
<ul>
<li>the resource mangers are ready to start a transaction;</li>
<li>the sole transaction manager is ready to start a transaction;</li>
<li>the transaction manager's view of each resource manager indicates that none
have indicated that they are preparing a transaction;</li>
<li>and the network is an empty set.</li>
</ul>
<p>Note that set semantics provide an ideal model for a network in this case
because they capture the fact that networks rarely make guarantees about
message order.  Those guarantees must be imposed by additional protocols. And
keep in mind that often those protocols only provide guarantees under limited
scopes (e.g. TCP only orders messages within the lifetime of that connection,
so a transient network partition can still cause message redelivery with TCP).</p>
<table><tr><td>
<pre><code class="language-ignore noplayground">Init ==   
  /\ rmState = [rm \in RM |-&gt; &quot;working&quot;]
  /\ tmState = &quot;init&quot;
  /\ tmPrepared   = {}
  /\ msgs = {}
</code></pre>
</td><td>
<pre><code class="language-rust ignore noplayground">fn init_states(&amp;self) -&gt; Vec&lt;Self::State&gt; {
    vec![TwoPhaseState {
        rm_state: self.rms.clone().map(|_| RmState::Working).collect(),
        tm_state: TmState::Init,
        tm_prepared: self.rms.clone().map(|_| false).collect(),
        msgs: Default::default(),
    }]
}
</code></pre>
</td></tr></table>
<p>Now we get to the most interesting part of the model, the state transitions
(which Stateright calls
<a href="https://docs.rs/stateright/latest/stateright/trait.Model.html#tymethod.actions">actions</a>).
TLA+ requires each transition relation to precede the aggregate next state
relation (<code>Next</code> in this case). Each action serves two roles: (1) it defines
its own preconditions and (2) it definies the subsequent state change (along
with the unchanged states). In Stateright it is more idiomatic (and performant)
to distinguish between the preconditions (in <code>fn actions...</code>) and state change
(in <code>fn next_state...</code>).</p>
<table><tr><td>
<pre><code class="language-ignore noplayground">TMCommit ==
  /\ tmState = &quot;init&quot;
  /\ tmPrepared = RM
  /\ tmState' = &quot;committed&quot;
  /\ msgs' = msgs \cup {[type |-&gt; &quot;Commit&quot;]}
  /\ UNCHANGED &lt;&lt;rmState, tmPrepared&gt;&gt;

TMAbort ==
  /\ tmState = &quot;init&quot;
  /\ tmState' = &quot;aborted&quot;
  /\ msgs' = msgs \cup {[type |-&gt; &quot;Abort&quot;]}
  /\ UNCHANGED &lt;&lt;rmState, tmPrepared&gt;&gt;

TMRcvPrepared(rm) ==
  /\ tmState = &quot;init&quot;
  /\ [type |-&gt; &quot;Prepared&quot;, rm |-&gt; rm] \in msgs
  /\ tmPrepared' = tmPrepared \cup {rm}
  /\ UNCHANGED &lt;&lt;rmState, tmState, msgs&gt;&gt;

RMPrepare(rm) == 
  /\ rmState[rm] = &quot;working&quot;
  /\ rmState' = [rmState EXCEPT ![rm] = &quot;prepared&quot;]
  /\ msgs' = msgs \cup {[type |-&gt; &quot;Prepared&quot;, rm |-&gt; rm]}
  /\ UNCHANGED &lt;&lt;tmState, tmPrepared&gt;&gt;
  
RMChooseToAbort(rm) ==
  /\ rmState[rm] = &quot;working&quot;
  /\ rmState' = [rmState EXCEPT ![rm] = &quot;aborted&quot;]
  /\ UNCHANGED &lt;&lt;tmState, tmPrepared, msgs&gt;&gt;

RMRcvCommitMsg(rm) ==
  /\ [type |-&gt; &quot;Commit&quot;] \in msgs
  /\ rmState' = [rmState EXCEPT ![rm] = &quot;committed&quot;]
  /\ UNCHANGED &lt;&lt;tmState, tmPrepared, msgs&gt;&gt;

RMRcvAbortMsg(rm) ==
  /\ [type |-&gt; &quot;Abort&quot;] \in msgs
  /\ rmState' = [rmState EXCEPT ![rm] = &quot;aborted&quot;]
  /\ UNCHANGED &lt;&lt;tmState, tmPrepared, msgs&gt;&gt;

Next ==
  \/ TMCommit \/ TMAbort
  \/ \E rm \in RM : 
       TMRcvPrepared(rm) \/ RMPrepare(rm) \/ RMChooseToAbort(rm)
         \/ RMRcvCommitMsg(rm) \/ RMRcvAbortMsg(rm)
</code></pre>
</td><td>
<pre><code class="language-rust ignore noplayground">fn actions(&amp;self, state: &amp;Self::State, actions: &amp;mut Vec&lt;Self::Action&gt;) {
    if state.tm_state == TmState::Init
            &amp;&amp; state.tm_prepared.iter().all(|p| *p) {
        actions.push(Action::TmCommit);
    }
    if state.tm_state == TmState::Init {
        actions.push(Action::TmAbort);
    }
    for rm in self.rms.clone() {
        if state.tm_state == TmState::Init
                &amp;&amp; state.msgs.contains(&amp;Message::Prepared { rm }) {
            actions.push(Action::TmRcvPrepared(rm));
        }
        if state.rm_state.get(rm) == Some(&amp;RmState::Working) {
            actions.push(Action::RmPrepare(rm));
        }
        if state.rm_state.get(rm) == Some(&amp;RmState::Working) {
            actions.push(Action::RmChooseToAbort(rm));
        }
        if state.msgs.contains(&amp;Message::Commit) {
            actions.push(Action::RmRcvCommitMsg(rm));
        }
        if state.msgs.contains(&amp;Message::Abort) {
            actions.push(Action::RmRcvAbortMsg(rm));
        }
    }
}

fn next_state(&amp;self, last_state: &amp;Self::State, action: Self::Action)
        -&gt; Option&lt;Self::State&gt; {
    let mut state = last_state.clone();
    match action {
        Action::TmRcvPrepared(rm) =&gt; {
            state.tm_prepared[rm] = true;
        }
        Action::TmCommit =&gt; {
            state.tm_state = TmState::Committed;
            state.msgs.insert(Message::Commit);
        }
        Action::TmAbort =&gt; {
            state.tm_state = TmState::Aborted;
            state.msgs.insert(Message::Abort);
        },
        Action::RmPrepare(rm) =&gt; {
            state.rm_state[rm] = RmState::Prepared;
            state.msgs.insert(Message::Prepared { rm });
        },
        Action::RmChooseToAbort(rm) =&gt; {
            state.rm_state[rm] = RmState::Aborted;
        }
        Action::RmRcvCommitMsg(rm) =&gt; {
            state.rm_state[rm] = RmState::Committed;
        }
        Action::RmRcvAbortMsg(rm) =&gt; {
            state.rm_state[rm] = RmState::Aborted;
        }
    }
    Some(state)
}
</code></pre>
</td></tr></table>
<p>Then we get to the sole property: if a resource manager reaches a final
commit/abort state, then no other resource manager can disagree with that
decision.</p>
<table><tr><td>
<pre><code class="language-ignore noplayground">Consistent ==
  \A rm1, rm2 \in RM : ~ /\ rmState[rm1] = &quot;aborted&quot;
                         /\ rmState[rm2] = &quot;committed&quot;
</code></pre>
</td><td>
<pre><code class="language-rust ignore noplayground">fn properties(&amp;self) -&gt; Vec&lt;Property&lt;Self&gt;&gt; {
    vec![
        Property::&lt;Self&gt;::always(&quot;consistent&quot;, |_, state| {
           !state.rm_state.iter().any(|s1|
                state.rm_state.iter().any(|s2|
                    s1 == &amp;RmState::Aborted &amp;&amp; s2 == &amp;RmState::Committed))
        }),
    ]
}
</code></pre>
</td></tr></table>
<h1><a class="header" href="#performance-comparison" id="performance-comparison">Performance Comparison</a></h1>
<p>Now we need to configure the model. For TLC, this is done via a special &quot;CFG&quot;
file, while for Stateright you simply introduce a Rust test. Rust also requires
a <code>Cargo.toml</code> file.</p>
<table><tr><td>
<pre><code class="language-ignore noplayground">SPECIFICATION Spec
INVARIANT TypeOK
INVARIANT Consistent
CONSTANTS
  RM = {0,1,2,3,4,5,6,7}
</code></pre>
</td><td>
<pre><code class="language-rust ignore noplayground">#[cfg(test)]
#[test]
fn can_model_2pc() {
    use stateright::Checker;
    TwoPhaseSys { rms: 0..8 }.checker()
        .threads(num_cpus::get()).spawn_dfs().join()
    	.assert_properties();
}
</code></pre>
<pre><code class="language-rust ignore noplayground">[package]
name = &quot;comparison-with-tlaplus&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
num_cpus = &quot;1&quot;
stateright = &quot;0.23&quot;
</code></pre>
</td></tr></table>
<p>TLA+ can be run from the command line using a tool such as
<a href="https://github.com/pmer/tla-bin">tla-bin</a> or
<a href="https://github.com/hwayne/tlacli">tlacli</a>, while the Stateright test is run
using <code>cargo test --release</code>. The example below first calls <code>build --tests</code> to
avoid timing dependency compilation but then revises the file timestamp to
include compilation time relevant to the development iteration cycle.
enables native compilation since the resulting binary does not need to be
distributed.</p>
<table><tr><td>
<pre><code class="language-ignore noplayground">$ tlc -workers auto TwoPhase.tla  
</code></pre>
</td><td>
<pre><code class="language-ignore noplayground">$ export RUSTFLAGS='-C target-cpu=native'  
$ cargo build --tests --release
$ touch src/lib.rs
$ time cargo test --release
</code></pre>
</td></tr></table>
<p>Stateright is generally faster, and the speedup tends to increase with larger
state spaces. A comparison of model checking times on the author's laptop
follows.</p>
<p><img src="comparison-with-tlaplus.performance.svg" alt="plot of checking time (y) against state count (x)" /></p>
<table><thead><tr><th>#RM</th><th>States</th><th>TLC</th><th>Stateright</th><th>Speedup</th></tr></thead><tbody>
<tr><td>7</td><td>296,448</td><td>3 s</td><td>1.697 s</td><td>1.8X</td></tr>
<tr><td>8</td><td>1,745,408</td><td>12 s</td><td>2.566 s</td><td>4.7X</td></tr>
<tr><td>9</td><td>10,340,352</td><td>90 s</td><td>8.902 s</td><td>10.1X</td></tr>
<tr><td>10</td><td>61,515,776</td><td>674 s</td><td>54.709 s</td><td>12.3X</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
