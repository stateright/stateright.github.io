<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Distributed Systems With Stateright</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Building Distributed Systems With Stateright</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="taming-the-network.html"><strong aria-hidden="true">2.</strong> Taming the Network</a></li><li class="chapter-item expanded "><a href="seeking-consensus.html"><strong aria-hidden="true">3.</strong> Seeking Consensus</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Building Distributed Systems With Stateright</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/stateright/stateright.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p><img src="https://img.shields.io/badge/Library_Links:-gray" alt="links" />
<a href="https://discord.gg/JbxGSVP4A6"><img src="https://img.shields.io/discord/781357978652901386" alt="chat" /></a>
<a href="https://crates.io/crates/stateright"><img src="https://img.shields.io/crates/d/stateright.svg" alt="crates.io" /></a>
<a href="https://docs.rs/stateright"><img src="https://docs.rs/stateright/badge.svg" alt="docs.rs" /></a>
<a href="https://github.com/stateright/stateright/stargazers"><img src="https://img.shields.io/github/stars/stateright/stateright?style=social" alt="stars" /></a>
<a href="https://github.com/stateright/stateright/watchers"><img src="https://img.shields.io/github/watchers/stateright/stateright?style=social" alt="watchers" /></a></p>
</blockquote>
<h1><a class="header" href="#building-distributed-systems-with-stateright" id="building-distributed-systems-with-stateright">Building Distributed Systems With Stateright</a></h1>
<p><em>by Jonathan Nadal</em></p>
<blockquote>
<p>Deep understanding of causality sometimes requires the understanding of very
large patterns and their abstract relationships and interactions, not just the
understanding of microscopic objects interacting in microscopic time intervals.</p>
<p>â€• Douglas R. Hofstadter, <em>I Am a Strange Loop</em></p>
</blockquote>
<p>Distributed computing is a term that refers to multiple computers working
together <em>as a system</em> to solve a problem, typically because that problem would
not be solvable on a single computer. For example, we all want to know that our
important files will be accessible even when computer hardware inevitably
fails. As a second example, a researcher at a pharmaceutical company may have a
complex problem that would take decades for a single computer to solve, but
which a collection of computers working together could solve in days.</p>
<p>Unique algorithms must be employed to coordinate workloads across these
geographically distributed systems of computers because they are susceptible to
categories of nondeterminism that do not arise when a problem is solved with a
single computer. For example, the networks that link these computers will drop,
reorder, and even redeliver messages. Algorithms that fail to account for this
behavior may run correctly for extended periods but will eventually fail at
unpredicatable times in unpredictable ways, such as causing data corruption.</p>
<p>Stateright is a software framework for analyzing and systematically verifying
distributed systems. Its name refers to the goal of verifying that a system's
collective state always satisfies a correctness specification, such as &quot;any
data written to the system should be accessible as long as at least one data
center is reachable.&quot;</p>
<p>Cloud service providers like AWS and Azure leverage verification software such
as <a href="https://lamport.azurewebsites.net/tla/industrial-use.html">the TLA+ model
checker</a> to achieve
the same goal, but whereas those solutions typically verify a high level system
design, Stateright is able to verify the underlying system <em>implementation</em> in
addition to the design.</p>
<p>We'll jump right in with a motivating example in the first chapter, <a href="./getting-started.html">Getting
Started</a>.</p>
<h1><a class="header" href="#chapter-1-getting-started" id="chapter-1-getting-started">Chapter 1: Getting Started</a></h1>
<blockquote>
<p><strong>IMPORTANT</strong>: Stateright is a relatively new framework and will be making breaking API
changes leading up to a 1.0 release, at which point the API will be considered
stable. If you plan to use Stateright for production scenarios, then please
<a href="https://github.com/stateright/stateright/issues/new">file a GitHub issue</a> so
that the author can coordinate with you to minimize any disruption.</p>
</blockquote>
<p>Let's start with the simplest nontrivial distributed system: a single client
that can interact with a single server by reading or writing a value. We'll see
that even this minimal example is susceptible to surprising behavior.</p>
<p><a href="https://www.rust-lang.org/learn/get-started">Install the Rust programming
language</a> if it is not already
installed, then initialize a new project using the <code>cargo</code> utility included
with Rust. If you are new to Rust, then you may want to review some of the
language's <a href="https://www.rust-lang.org/learn">learning resources</a>.</p>
<pre><code class="language-sh">mkdir getting-started
cd getting-started
cargo init
</code></pre>
<p>Define dependencies in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[package]
name = &quot;getting-started&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
env_logger = &quot;0.7&quot;
serde_json = &quot;1.0&quot;
stateright = &quot;0.22.0&quot;
</code></pre>
<p>Here is the complete implementation for <code>main.rs</code>. Copy-paste it into your own
file. The next section explains the most important aspects.</p>
<pre><code class="language-rust ignore noplayground">
use stateright::actor::{*, register::*};
use std::borrow::Cow; // COW == clone-on-write
use std::net::{SocketAddrV4, Ipv4Addr};

// Here we have an actor that represents a &quot;virtual register.&quot; As you would expect, `Put` messages
// indicate a value to store, while `Get` messages return the last stored value. Response messages
// are associated with request messages via an integer &quot;request ID&quot; that is expected to be unique.
// The Stateright library provides a `RegisterMsg` type for this common pattern.

type RequestId = u64;

#[derive(Clone)]
struct ActorContext;

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = char;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        '?' // default value for the register
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                *state.to_mut() = value;
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, **state));
            }
            _ =&gt; {}
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use stateright::*;
    use RegisterMsg::{Get, GetOk, Put, PutOk};
    use SystemAction::Deliver;

    // It turns out that even this minimal example of an actor system has a subtle bug, and this is
    // a category of bug present in many (if not *most*) distributed systems. The bug can manifest
    // even if there is a single server and a single client.
    #[test]
    fn is_unfortunately_not_linearizable() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            // Here is a counterexample that Stateright will confirm. Each step indicates an
            // incoming event observed by an actor For brevity counterexamples show actor inputs
            // such as `Deliver` but not outputs such as `Send`.
            //
            // 1. The server receives a write from the client (which it acknowledges).
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            // 2. The client receives the ack (and sends a second write with a new value).
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(1) },
            // 3. The server receives the second write (which it acknowledges).
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(2, 'Z') },
            // 4. The network redelivers the first write, inadvertently overwriting the second.
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            // 5. The client receives the ack for the second write (and sends a read request).
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(2) },
            // 6. The server receives the read request (and replies with the current value).
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Get(3) },
            // 7. The client receives a value that violates linearizability. QED.
            Deliver { src: Id::from(0), dst: Id::from(1), msg: GetOk(3, 'A') },
        ]);
    }
}

// Running the program spawns a single actor on UDP port 3000. Messages are JSON-serialized.
fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    let handles = spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000), ActorContext)
        ]);
    for h in handles { let _ = h.join(); }
}

</code></pre>
<h2><a class="header" href="#implementation-walkthrough" id="implementation-walkthrough">Implementation Walkthrough</a></h2>
<p>The code starts by implementing a simple server using the &quot;<a href="https://en.wikipedia.org/wiki/Actor_model">actor
model</a>.&quot; An actor is an event
oriented process that is able to communicate with other actors over a network
by sending messages.</p>
<p>The server responds to <code>Put</code> and <code>Get</code> messages based only on its own local
state, providing its clients with a simple form of distributed storage,
sometimes known as a <a href="https://en.wikipedia.org/wiki/Shared_register">shared
register</a>.  Responses are linked
to requests via a request ID chosen by the client.</p>
<pre><code class="language-rust ignore noplayground">
type RequestId = u64;

#[derive(Clone)]
struct ActorContext;

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = char;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        '?' // default value for the register
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                *state.to_mut() = value;
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, **state));
            }
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>A test follows. It employs a technique called model checking that is similar
to <a href="https://github.com/BurntSushi/quickcheck">property based testing</a>, wherein
the programmer writes a predicate indicating what constitutes correct behavior;
for example, &quot;<em>the function's output is a sorted permutation of its input</em>.&quot;
But whereas property based testing often enumerates the outputs of a
deterministic algorithm based on a random sampling of possible inputs, model
checking often systematically enumerates the reachable states of a
nondeterministic system with less focus on the variety of initial inputs; for
example &quot;<em>if clients write <code>X</code> followed by <code>Y</code> to the the same database key
<code>K</code>, then a subsequent read may only return <code>Y</code> until the next write,
regardless of how the network reorders or redelivers messages</em>.&quot;</p>
<p>The test checks the system for a property called
<a href="https://en.wikipedia.org/wiki/Linearizability">linearizability</a>, which loosely
speaking means that the visible behavior of the register abstraction provided
by the actors is identical to that of a register within a single-threaded
system.</p>
<blockquote>
<p><strong>Terminology</strong>: The term &quot;linearizable&quot; derives from the insight that the
operations executed by a system form a directed acyclic graph where edges
indicate &quot;happens before.&quot; For example, if Computer1 sends messages to invoke
operations on Computer2 and Computer3, then the message sends happens before
Computer2 or Computer3 handle them, but the handling of the messages by
Computer2 and Computer 3 lack a defined order because the messages
<a href="https://en.wikipedia.org/wiki/Race_condition">race</a>. A &quot;linearization&quot; defines
a viable linear order such as &quot;Computer 1 sends the messages, Computer 3
handles one, and then Computer2 handles the other.&quot; A system is not
linearizable when its behavior cannot be mapped to a linearization. For
example, if the operation invoked on Computer2 was <code>Append &quot;Hello&quot;</code> and
Computer3 was <code>Append &quot;World&quot;</code>, but the final value interlaced the inputs to
form <code>&quot;WolloHerld&quot;</code>, then the system would not be linearizable. Either
<code>&quot;HelloWorld&quot;</code> or <code>&quot;WorldHello&quot;</code> on the other hand would be valid
linearizations since the messages race.</p>
</blockquote>
<p>The test leverages
<a href="https://docs.rs/stateright/0.18.0/stateright/actor/register/struct.RegisterTestSystem.html"><code>RegisterTestSystem</code></a>,
which is built into Stateright and defines a system whereby a specified number
of clients (only 1 in this case) write distinct values and independently read
values without coordinating with one another. Under the hood
<code>RegisterTestSystem</code> also leverages Stateright's built-in
<a href="https://docs.rs/stateright/latest/stateright/semantics/struct.LinearizabilityTester.html"><code>LinearizabilityTester</code></a>.</p>
<p>Stateright is able to find a bug that arises even if there is only a single
client. The bug manifests whenever the network redeliveries messages, something
that can and does happen in practice.</p>
<pre><code class="language-rust ignore noplayground">    #[test]
    fn is_unfortunately_not_linearizable() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            // Here is a counterexample that Stateright will confirm. Each step indicates an
            // incoming event observed by an actor For brevity counterexamples show actor inputs
            // such as `Deliver` but not outputs such as `Send`.
            //
            // 1. The server receives a write from the client (which it acknowledges).
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            // 2. The client receives the ack (and sends a second write with a new value).
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(1) },
            // 3. The server receives the second write (which it acknowledges).
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(2, 'Z') },
            // 4. The network redelivers the first write, inadvertently overwriting the second.
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            // 5. The client receives the ack for the second write (and sends a read request).
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(2) },
            // 6. The server receives the read request (and replies with the current value).
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Get(3) },
            // 7. The client receives a value that violates linearizability. QED.
            Deliver { src: Id::from(0), dst: Id::from(1), msg: GetOk(3, 'A') },
        ]);
    }
</code></pre>
<p>The last bit of code defines the <code>main</code> method, which runs the actor on a UDP
socket, encoding messages with the JSON format.</p>
<pre><code class="language-rust ignore noplayground">fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    let handles = spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000), ActorContext)
        ]);
    for h in handles { let _ = h.join(); }
}
</code></pre>
<h2><a class="header" href="#running" id="running">Running</a></h2>
<p>Confirm the system behaves as expected by running the test, which should pass
because the test asserts that the bug exists. It's a good idea to get into the
habit of passing the <code>--release</code> flag when testing more complex systems so that
Rust fully optimizes the code, as testing can be computationally intensive and
time consuming.</p>
<pre><code class="language-sh">cargo test --release
</code></pre>
<p>Now run the actor on a UDP socket.</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>If using a POSIX-oriented operating system,
<a href="https://en.wikipedia.org/wiki/Netcat">netcat</a> can be used to interact with the
actor from a different terminal window. Actor responses are omitted from the
listing below for clarity, but you will see messages such as <code>{&quot;PutOk&quot;:0}</code>
printed to STDOUT. Numbers in the messages are request IDs, the importance of
which will be more evident in the next chapter.</p>
<pre><code class="language-sh">nc -u localhost 3000
{&quot;Put&quot;:[0,&quot;X&quot;]}
{&quot;Get&quot;:1}
{&quot;Put&quot;:[2,&quot;X&quot;]}
{&quot;Get&quot;:3}
</code></pre>
<h2><a class="header" href="#exercise" id="exercise">Exercise</a></h2>
<p>Uncomment the <code>// TRY IT</code> line, then run the test again. It should fail
indicating a sequence of steps that would cause the linearizability expectation
to be violated. This exercise demonstrates how Stateright can detect flaws that
would likely go undetected when simply reviewing the actor implementation.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>This chapter introduced one of the simplest possible distributed systems and
showed how Stateright can find a subtle bug. The next chapter <a href="./taming-the-network.html">Taming the
Network</a> will address that bug.</p>
<h1><a class="header" href="#chapter-2-taming-the-network" id="chapter-2-taming-the-network">Chapter 2: Taming the Network</a></h1>
<p>In the last chapter we discovered a bug caused by the network's susceptibility
to message redelivery. We address that in this chapter.</p>
<p>Initialize a new Rust project:</p>
<pre><code class="language-sh">mkdir taming-the-network
cd taming-the-network
cargo init
</code></pre>
<p>Then add dependencies to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;taming-the-network&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
env_logger = &quot;0.7&quot;
serde_json = &quot;1.0&quot;
stateright = &quot;0.22.0&quot;
</code></pre>
<p>Here is the complete implementation for <code>main.rs</code>, explained below:</p>
<pre><code class="language-rust ignore noplayground">
use stateright::actor::{*, register::*};
use std::borrow::Cow;
use std::collections::BTreeSet;
use std::net::{SocketAddrV4, Ipv4Addr};

type RequestId = u64;

#[derive(Clone)]
struct ActorContext;

#[derive(Clone, Debug, Hash, PartialEq)]
struct ActorState {
    value: char,
    delivered: BTreeSet&lt;(Id, RequestId)&gt;,
}

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = ActorState;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        ActorState {
            value: '?',
            delivered: Default::default(),
        }
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, state.value));
            }
            _ =&gt; {}
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use stateright::*;
    use RegisterMsg::{Get, GetOk, Put, PutOk};
    use SystemAction::Deliver;

    #[test]
    fn satisfies_all_properties() {
        // Works with 1 client.
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        checker.assert_properties();

        // Or with multiple clients.
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 2, // TIP: test with `--release` mode for more clients
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        checker.assert_properties();
    }

    #[test]
    fn not_linearizable_with_two_servers() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext, ActorContext], // two servers
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Put(2, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(2), msg: PutOk(2) },
            Deliver { src: Id::from(2), dst: Id::from(1), msg: Put(4, 'Z') },
            Deliver { src: Id::from(1), dst: Id::from(2), msg: PutOk(4) },
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Get(6) },
            Deliver { src: Id::from(0), dst: Id::from(2), msg: GetOk(6, 'A') },
        ]);
    }
}

// Running the program spawns a single actor on UDP port 3000. Messages are JSON-serialized.
fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    let handles = spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000), ActorContext)
        ]);
    for h in handles { let _ = h.join(); }
}

</code></pre>
<h2><a class="header" href="#implementation-walkthrough-1" id="implementation-walkthrough-1">Implementation Walkthrough</a></h2>
<p>Addressing the linearizability issue is merely a matter of throwing away
message redeliveries. The simplest approach is to record every delivered request ID.</p>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Hash, PartialEq)]
struct ActorState {
    value: char,
    delivered: BTreeSet&lt;(Id, RequestId)&gt;,
}

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = ActorState;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        ActorState {
            value: '?',
            delivered: Default::default(),
        }
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, state.value));
            }
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>With that small change, each server provides an independent linearizable
register. In the presence of messages concurrently in flight, the register
abstraction is still
<a href="https://en.wikipedia.org/wiki/Linearizability">linearizable</a> (for example,
reads cannot observe values overwritten before the read began, among other
characteristics).</p>
<p>The servers feature no replication, so a <em>collection</em> of servers does not provide
a unified service that emulates a linearizable register as the servers will not
generally agree upon the last value they received.</p>
<pre><code class="language-rust ignore noplayground">    #[test]
    fn satisfies_all_properties() {
        // Works with 1 client.
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        checker.assert_properties();

        // Or with multiple clients.
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 2, // TIP: test with `--release` mode for more clients
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        checker.assert_properties();
    }

    #[test]
    fn not_linearizable_with_two_servers() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext, ActorContext], // two servers
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Put(2, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(2), msg: PutOk(2) },
            Deliver { src: Id::from(2), dst: Id::from(1), msg: Put(4, 'Z') },
            Deliver { src: Id::from(1), dst: Id::from(2), msg: PutOk(4) },
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Get(6) },
            Deliver { src: Id::from(0), dst: Id::from(2), msg: GetOk(6, 'A') },
        ]);
    }
</code></pre>
<h2><a class="header" href="#suggested-exercises" id="suggested-exercises">Suggested Exercises</a></h2>
<ol>
<li><strong>Compaction</strong>: Storing every request ID isn't viable for a long running
process.  The simplest approach is to require that request IDs are
&quot;monotonic&quot; -- which means they are increasing (and gaps are acceptable). In
that case, the delivery handler throws away messages with a request ID
smaller than the last handled message. See if you can amend the example
accordingly.</li>
<li><strong>Optimized Compaction</strong>: Reordered messages will be dropped because late
delivered message will have a smaller request ID. Protocols need to account
for the network dropping messages anyway, so generally speaking this
tradeoff only impacts performance. Still, throughput can be improved by
adding a &quot;sliding window&quot; buffer on the server side to minimize dropped
messages. See if you can implement that.</li>
<li><strong>Lossless Link</strong>: One technique for minimizing message loss is to have
the client also maintain a buffer of outgoing messages, and the client
periodically resends messages that have not been acknowledged by the
recipient within a particular timeout period. TCP for example does this for
packets. See if you can implement this as well. If you need help, see
<a href="https://github.com/stateright/stateright/blob/master/src/actor/ordered_reliable_link.rs"><code>ordered_reliable_link.rs</code></a> in the Stateright repository.</li>
</ol>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>This chapter showed how to fix the implementation from the previous chapter,
maintaining linearizability even if messages are redelivered. The next chapter
<a href="./seeking-consensus.html">Seeking Consensus</a> will introduce the concept of
replication, which is used to provide (1) data recoverability in the event of a
server crash and/or (2) improved performance for high request rates by
distributing requests (such as reads) across a wider range of hosts.</p>
<h1><a class="header" href="#chapter-3-seeking-consensus" id="chapter-3-seeking-consensus">Chapter 3: Seeking Consensus</a></h1>
<p>In the last chapter we fixed a bug caused by the network's susceptibility to
message redelivery, but our solution could only run on a single server.
Introducing a second server would break linearizability as the system failed to
replicate information between servers.</p>
<p>In this chapter we introduce a simple replication protocol in an attempt to
address that shortcoming.</p>
<p>Once again, we start by initializing a new Rust project:</p>
<pre><code class="language-sh">mkdir seeking-consensus
cd seeking-consensus
cargo init
</code></pre>
<p>Next we add dependencies to <code>Cargo.toml</code>. Notice that we now need to include
the <code>serde</code> package.</p>
<pre><code class="language-toml">[package]
name = &quot;seeking-consensus&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
env_logger = &quot;0.7&quot;
serde = &quot;1.0&quot;
serde_json = &quot;1.0&quot;
stateright = &quot;0.22.0&quot;
</code></pre>
<p>By now you have the hang of implementing basic actor systems in Stateright, so
we'll defer the full <code>main.rs</code> source code listing until later in the chapter.</p>
<h2><a class="header" href="#a-replication-protocol" id="a-replication-protocol">A Replication Protocol</a></h2>
<p>First we get to decide on a replication protocol. Give this some thought, and
see if you have ideas.</p>
<blockquote>
<p><strong>Exercise</strong>: Yes, really. Take some time to think about how you might add
replication.</p>
</blockquote>
<p>Done? Great!</p>
<p>For this example, we'll proceed with a protocol that simply involves forwarding
the value to every peer server before replying to the client, thereby ensuring
the servers agree on the value. This might be the protocol that you envisioned
as well.</p>
<h2><a class="header" href="#implementation-walkthrough-2" id="implementation-walkthrough-2">Implementation Walkthrough</a></h2>
<p>The first notable difference is the need to introduce a message type for
replication.</p>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Hash, Eq, PartialEq)]
#[derive(Deserialize, Serialize)]
enum InternalMsg {
    Replicate(RequestId, char),
    ReplicateOk(RequestId),
}
</code></pre>
<p>The server defers sending a <code>PutOk</code> message until replicas reply, but
Stateright actors are nonblocking, so they must manage some additional state:</p>
<ul>
<li>the ID of the request, against which replica replies are matched (to guard
against late responses),</li>
<li>the ID of the client that made the request (to facilitate replying later),</li>
<li>and the set of servers that have acknowledged the replicated value (to
facilitate waiting until all have replied).</li>
</ul>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Hash, PartialEq)]
struct ActorState {
    value: char,
    delivered: BTreeSet&lt;(Id, RequestId)&gt;,
    in_flight_put: Option&lt;PutState&gt;,
}

#[derive(Clone, Debug, Hash, PartialEq)]
struct PutState {
    req_id: RequestId,
    src: Id,
    peer_acks: BTreeSet&lt;Id&gt;,
}
</code></pre>
<p>We are now ready to implement the protocol.</p>
<pre><code class="language-rust ignore noplayground">    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) if state.in_flight_put.is_none() =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                state.in_flight_put = Some(PutState {
                    req_id,
                    src,
                    peer_acks: Default::default(),
                });
                for &amp;peer_id in &amp;self.peer_ids {
                    o.send(peer_id,
                           RegisterMsg::Internal(
                               InternalMsg::Replicate(req_id, value)));
                }
                // Will not reply w/ `PutOk` until all replicas ack.
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, state.value));
            }
            RegisterMsg::Internal(InternalMsg::Replicate(req_id, value)) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                o.send(src,
                       RegisterMsg::Internal(InternalMsg::ReplicateOk(req_id)));
            }
            RegisterMsg::Internal(InternalMsg::ReplicateOk(req_id)) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                if let Some(put) = &amp;mut state.in_flight_put {
                    if req_id != put.req_id { return }

                    put.peer_acks.insert(src);
                    if put.peer_acks == self.peer_ids {
                        o.send(put.src, RegisterMsg::PutOk(req_id));
                        state.in_flight_put = None;
                    }
                }
            }
            _ =&gt; {}
        }
    }
</code></pre>
<p>Now the big question: does this protocol solve the problem we ran
into last chapter?</p>
<p>Unfortunately achieving linearizability involves a bit more sophistication, and
Stateright identifies a sequence of steps that are not linearizable. The
sequence is nontrivial and demonstrates why a model checker is so useful for
implementing distributed systems.</p>
<pre><code class="language-rust ignore noplayground">        // Fails if there are 3 clients.
        let checker = RegisterTestSystem {
            servers: vec![
                ActorContext { peer_ids: vec![Id::from(1)].into_iter().collect() },
                ActorContext { peer_ids: vec![Id::from(0)].into_iter().collect() },
            ],
            client_count: 3,
            .. Default::default()
        }.into_model().checker()
        .spawn_dfs().join();     // TRY IT: Comment out this line, and uncomment
        //.serve(&quot;0:3000&quot;);      //         the next to load Stateright Explorer.
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(4), dst: Id::from(0), msg: Put(4, 'C') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: Internal(Replicate(4, 'C')) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Internal(ReplicateOk(4)) },
            Deliver { src: Id::from(3), dst: Id::from(1), msg: Put(3, 'B') },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Internal(Replicate(3, 'B')) },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: Internal(ReplicateOk(3)) },
            Deliver { src: Id::from(1), dst: Id::from(3), msg: PutOk(3) },
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Put(2, 'A') },
            Deliver { src: Id::from(3), dst: Id::from(0), msg: Get(6) },
            Deliver { src: Id::from(0), dst: Id::from(3), msg: GetOk(6, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(4), msg: PutOk(4) },
            Deliver { src: Id::from(4), dst: Id::from(1), msg: Get(8) },
            Deliver { src: Id::from(1), dst: Id::from(4), msg: GetOk(8, 'B') },
        ]);
</code></pre>
<h2><a class="header" href="#stateright-explorer" id="stateright-explorer">Stateright Explorer</a></h2>
<p>It's not immediately clear why the sequence of steps identified by Stateright
violates linearizability. Luckily Stateright includes a web UI that can help
you understand scenarios such as this one.</p>
<p>Stateright Explorer is started by calling
<a href="https://docs.rs/stateright/latest/stateright/struct.CheckerBuilder.html#method.serve"><code>serve(...)</code></a>.
You can easily do this by following the directions in the first <code>// TRY IT</code> line,
which will suspend the test when it is next run, allowing you to load
<code>http://localhost:3000</code> in your web browser to debug.</p>
<blockquote>
<p><strong>Tip</strong>: Model checking with Stateright Explorer is breadth-first, as that
tends to find shorter discovery paths than depth-first search. One downside of
this approach is that breadth-first search consumes more memory, so Explorer
works best with relatively small state spaces (hundreds of thousands of states
rather than millions of states, for example).</p>
</blockquote>
<p>When you load Stateright Explorer, you'll see the checker status in the upper
left corner. Within a few seconds the checker should add <code>&quot;linearizable&quot; counterexample</code> to its list of discoveries.</p>
<p><img src="seeking-consensus.explorer.png" alt="Stateright Explorer on load" /></p>
<p>Click that link to load the discovery.</p>
<p><img src="seeking-consensus.explorer2.png" alt="Stateright Explorer after clicking the link" /></p>
<p>The first thing you might notice is the
sequence diagram.</p>
<p><img src="seeking-consensus.sequence.png" alt="sequence diagram for the linearizability violation" /></p>
<p>Tracing backwards from the last event, we can see why linearizability is
violated:</p>
<ol>
<li><code>GetOk(8, 'B')</code> indicates that <code>'B'</code> is the earliest write finishing before
the read. Also, no operations are concurrent with the read.</li>
<li><code>PutOk(4)</code> was in response to the long running <code>Put(4, 'C')</code> operation,
indicating that the value <code>'C'</code> must have been written at some point between
invocation and response. Unlike the read, the precise sequencing of this
write in relation to other operations is indeterminate due to concurrency).</li>
<li><code>GetOk(6, 'A')</code> indicates that <code>'A'</code> is the earliest write finishing before
that read. Only the write of <code>'C'</code> is concurrent with the start and end of
the read, so it's possible that the write took effect before or after the
read took effect.</li>
</ol>
<p>We don't have to trace any further back, as those observations above highlight
the anomaly: <code>'A'</code> had been the most recent write, then <code>'C'</code> may or may not
have been written next (as the concurrency allows different linearizations),
and finally <code>'B'</code> was read. No linearization of concurrent operations can
reconcile this anomaly, so the protocol is not linearizable. QED.</p>
<h2><a class="header" href="#complete-implementation" id="complete-implementation">Complete Implementation</a></h2>
<p>Here is the complete implementation for <code>main.rs</code>:</p>
<pre><code class="language-rust ignore noplayground">
use serde::{Deserialize, Serialize};
use stateright::actor::{*, register::*};
use std::borrow::Cow;
use std::collections::BTreeSet;
use std::net::{SocketAddrV4, Ipv4Addr};

type RequestId = u64;

#[derive(Clone)]
struct ActorContext {
    peer_ids: BTreeSet&lt;Id&gt;,
}

#[derive(Clone, Debug, Hash, Eq, PartialEq)]
#[derive(Deserialize, Serialize)]
enum InternalMsg {
    Replicate(RequestId, char),
    ReplicateOk(RequestId),
}

#[derive(Clone, Debug, Hash, PartialEq)]
struct ActorState {
    value: char,
    delivered: BTreeSet&lt;(Id, RequestId)&gt;,
    in_flight_put: Option&lt;PutState&gt;,
}

#[derive(Clone, Debug, Hash, PartialEq)]
struct PutState {
    req_id: RequestId,
    src: Id,
    peer_acks: BTreeSet&lt;Id&gt;,
}

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, InternalMsg&gt;;
    type State = ActorState;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        ActorState {
            value: '?',
            delivered: Default::default(),
            in_flight_put: None,
        }
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) if state.in_flight_put.is_none() =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                state.in_flight_put = Some(PutState {
                    req_id,
                    src,
                    peer_acks: Default::default(),
                });
                for &amp;peer_id in &amp;self.peer_ids {
                    o.send(peer_id,
                           RegisterMsg::Internal(
                               InternalMsg::Replicate(req_id, value)));
                }
                // Will not reply w/ `PutOk` until all replicas ack.
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, state.value));
            }
            RegisterMsg::Internal(InternalMsg::Replicate(req_id, value)) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                state.value = value;
                state.delivered.insert((src, req_id));
                o.send(src,
                       RegisterMsg::Internal(InternalMsg::ReplicateOk(req_id)));
            }
            RegisterMsg::Internal(InternalMsg::ReplicateOk(req_id)) =&gt; {
                if state.delivered.contains(&amp;(src, req_id)) { return }

                let mut state = state.to_mut();
                if let Some(put) = &amp;mut state.in_flight_put {
                    if req_id != put.req_id { return }

                    put.peer_acks.insert(src);
                    if put.peer_acks == self.peer_ids {
                        o.send(put.src, RegisterMsg::PutOk(req_id));
                        state.in_flight_put = None;
                    }
                }
            }
            _ =&gt; {}
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use stateright::*;
    use InternalMsg::{Replicate, ReplicateOk};
    use RegisterMsg::{Get, GetOk, Internal, Put, PutOk};
    use SystemAction::Deliver;

    #[test]
    fn appears_linearizable_in_limited_scenarios() {
        // Succeeds if there are 2 clients.
        let checker = RegisterTestSystem {
            servers: vec![
                ActorContext { peer_ids: vec![Id::from(1)].into_iter().collect() },
                ActorContext { peer_ids: vec![Id::from(0)].into_iter().collect() },
            ],
            client_count: 2,
            .. Default::default()
        }.into_model().checker().spawn_bfs().join();
        checker.assert_properties();
    }

    #[test]
    fn not_generally_linearizable() {
        // Fails if there are 3 clients.
        let checker = RegisterTestSystem {
            servers: vec![
                ActorContext { peer_ids: vec![Id::from(1)].into_iter().collect() },
                ActorContext { peer_ids: vec![Id::from(0)].into_iter().collect() },
            ],
            client_count: 3,
            .. Default::default()
        }.into_model().checker()
        .spawn_dfs().join();     // TRY IT: Comment out this line, and uncomment
        //.serve(&quot;0:3000&quot;);      //         the next to load Stateright Explorer.
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(4), dst: Id::from(0), msg: Put(4, 'C') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: Internal(Replicate(4, 'C')) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Internal(ReplicateOk(4)) },
            Deliver { src: Id::from(3), dst: Id::from(1), msg: Put(3, 'B') },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Internal(Replicate(3, 'B')) },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: Internal(ReplicateOk(3)) },
            Deliver { src: Id::from(1), dst: Id::from(3), msg: PutOk(3) },
            Deliver { src: Id::from(2), dst: Id::from(0), msg: Put(2, 'A') },
            Deliver { src: Id::from(3), dst: Id::from(0), msg: Get(6) },
            Deliver { src: Id::from(0), dst: Id::from(3), msg: GetOk(6, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(4), msg: PutOk(4) },
            Deliver { src: Id::from(4), dst: Id::from(1), msg: Get(8) },
            Deliver { src: Id::from(1), dst: Id::from(4), msg: GetOk(8, 'B') },
        ]);
    }
}

// Running the program spawns actors on UDP ports 3000-3002. Messages are JSON-serialized.
fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    let id0 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000));
    let id1 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3001));
    let id2 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3002));
    let handles = spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (id0, ActorContext { peer_ids: vec![id1, id2].into_iter().collect() } ),
            (id1, ActorContext { peer_ids: vec![id0, id2].into_iter().collect() } ),
            (id2, ActorContext { peer_ids: vec![id0, id1].into_iter().collect() } ),
        ]);
    for h in handles { let _ = h.join(); }
}

</code></pre>
<h2><a class="header" href="#suggested-exercise" id="suggested-exercise">Suggested Exercise</a></h2>
<p>Uncomment the second <code>// TRY IT</code> line to cause the test to fail, delete the
linearizability counterexample assertion since it may not longer apply, and see
if you can amend the actor implementation to make the test pass. The next
chapter will provide a solution, but going through the exercise of trying to
design a solution youself will help convey how subtle bugs can be with
distributed protocols, and hopefully it will demonstrate why Stateright is so
useful for this problem space.</p>
<blockquote>
<p><strong>Reminder</strong>: use <code>cargo test --release</code> when running the tests for
dramatically better model checking performance. Running tests without that flag
may result in significant delays. Also, try using <a href="https://docs.rs/stateright/latest/stateright/struct.CheckerBuilder.html#method.serve">Stateright
Explorer</a>
for debugging as needed.</p>
</blockquote>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<p>This chapter introduced replication, and Stateright was able to find a bug in
our replication protocol. The next chapter will introduce a more sophisticated
protocol that makes the replicated register linearizable.</p>
<p>That next chapter is not yet available, so in the meantime you can learn more
about Stateright by browsing additional <a href="https://github.com/stateright/stateright/tree/master/examples">Stateright
examples</a> and
reviewing the <a href="https://docs.rs/stateright">Stateright API docs</a>.</p>
<p>If you have any questions, comments, or ideas, please share them on
<a href="https://discord.com/channels/781357978652901386">Stateright's Discord server</a>.
At this time Stateright is a small personal project, and the main author is
eager to hear community feedback.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
