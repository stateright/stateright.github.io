<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Achieving Linearizability - Building Distributed Systems With Stateright</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Building Distributed Systems With Stateright</a></li><li class="chapter-item expanded affix "><li class="part-title">Concepts</li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Protocols</li><li class="chapter-item expanded "><a href="taming-the-network.html"><strong aria-hidden="true">2.</strong> Taming the Network</a></li><li class="chapter-item expanded "><a href="seeking-consensus.html"><strong aria-hidden="true">3.</strong> Seeking Consensus</a></li><li class="chapter-item expanded "><a href="achieving-linearizability.html" class="active"><strong aria-hidden="true">4.</strong> Achieving Linearizability</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Achieving Consensus</div></li><li class="chapter-item expanded affix "><li class="part-title">Other Topics</li><li class="chapter-item expanded "><a href="comparison-with-tlaplus.html"><strong aria-hidden="true">6.</strong> Comparison with TLA+</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Building Distributed Systems With Stateright</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/stateright/stateright.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#chapter-4-achieving-linearizability" id="chapter-4-achieving-linearizability">Chapter 4: Achieving Linearizability</a></h1>
<p>In the last chapter we implemented a faulty replication protocol that violated
linearizability because the emulated register was not atomic. This chapter
introduces a more sophisticated replication protocol that the author first
learned about when reading the blog post &quot;<a href="https://muratbuffalo.blogspot.com/2012/05/replicatedfault-tolerant-atomic-storage.html">Replicated/Fault-tolerant atomic
storage</a>&quot;
by Murat Demirbas.</p>
<p>As usual, we start by initializing a new Rust project:</p>
<pre><code class="language-sh">mkdir achieving-linearizability
cd achieving-linearizability
cargo init
</code></pre>
<p>Then we define dependencies.</p>
<pre><code class="language-toml">[package]
name = &quot;achieving-linearizability&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
env_logger = &quot;0.7&quot;
num_cpus = &quot;1&quot;
serde = &quot;1.0&quot;
serde_json = &quot;1.0&quot;
stateright = &quot;0.30&quot;
</code></pre>
<h2><a class="header" href="#a-truly-atomic-register" id="a-truly-atomic-register">A Truly Atomic Register</a></h2>
<p>One problem with the earlier protocol is that reads can observe different
values depending on which server accepts the read. We need to amend the
protocol to ensure that given the same aggregate system state, any two reads
are guaranteed to observe the same value. The simplest solution is to query
every server when servicing a read operation, but that introduces yet another
problem: availability. By forcing reads to query every server, if a single
server becomes unavailable, the entire system becomes unavailable. This problem
also exists for writes in that replication protocol.</p>
<p>The trick to solving this new problem is observing that we only need to ensure
that &quot;read sets&quot; overlap one another. If a majority of servers agree on a
value, then we know that any other majority of servers must either agree on the
same value or must have a different value that is not part of the majority.  We
can apply the same logic to the &quot;write set&quot; as well.  We call the set of
sufficient reads a &quot;read quorum&quot; and the set of sufficient writes a &quot;write
quorum.&quot;</p>
<p>Leveraging read and write quorums solves the availability problem when a
minority of servers are unreachable, but we still have a second availability
problem: in many cases a read set will not agree on a value. This can happen if
the read is concurrent with a write or if two earlier writes were concurrent.
In those cases, the server accepting the read must either ignore the request or
return an error, upon which we can improve.</p>
<p>To solve this remaining problem, we simply need to force the system into
agreement, thereby ensuring any subsequent read either observes the forced
agreement or a subsequent write. This is the technique employed by Attiya,
Bar-Noy, and Dolev in their paper &quot;<a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.96.5395">Sharing Memory Robustly in Message-Passing
Systems</a>&quot;.</p>
<p>Both read and write operations are handled in two phases: (1) a <strong>query</strong> phase
followed by (2) a <strong>replication</strong> phase.</p>
<ul>
<li><strong>1. Query Phase</strong>: In the query phase, a server finds out what replicated
values a quorum of replicas has previously accepted. The replicas also
return a <a href="https://en.wikipedia.org/wiki/Logical_clock">logical clock</a> that
serves to sequence earlier write operations, so the implementation will refer
to this as a <em>sequencer</em>.</li>
<li><strong>2a. Write Replication Phase</strong>: If servicing a write, then upon receiving
responses from a quorum, the server replicates the chosen value along with a
slightly larger sequencer than the one observed. Once a majority of the
replicas ack this second phase, the server can indicate to the client that
the write is complete.</li>
<li><strong>2b. Read Replication Phase</strong>: If servicing a read, then upon receiving
responses from a quorum, the server replicates the value with the largest
observed sequencer. Once a majority of the replicas ack this second phase,
the server can return the value that it replicated.</li>
</ul>
<h2><a class="header" href="#implementation-walkthrough" id="implementation-walkthrough">Implementation Walkthrough</a></h2>
<p>We first define our message type. <code>Abd...</code> in the type refers to the names of
the algorithm's original author's -- Attiya, Bar-Noy, and Dolev -- or &quot;ABD.&quot;</p>
<pre><code class="language-rust ignore noplayground">type RequestId = u64;
type Value = char;

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[derive(Serialize, Deserialize)]
enum AbdMsg {
    Query(RequestId),
    AckQuery(RequestId, Seq, Value),
    Replicate(RequestId, Seq, Value),
    AckReplicate(RequestId),
}
</code></pre>
<p>The current implementation combines the roles of &quot;replica&quot; and &quot;coordinator
that accepts a request and facilitates replication.&quot; <code>seq</code> and <code>val</code> are for
the first role, while <code>phase</code> tracks information needed by the second role.</p>
<p>Of particular note is that for phase 1, writes need to remember what value to
later replicate, which is stored in <code>write</code>. Conversely for phase 2, reads need
to remember what value to later return to the client, which is stored in
<code>read</code>.</p>
<pre><code class="language-rust ignore noplayground">#[derive(Clone, Debug, Eq, Hash, PartialEq)]
struct AbdState {
    seq: Seq,
    val: Value,
    phase: Option&lt;AbdPhase&gt;,
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
enum AbdPhase {
    Phase1 {
        request_id: RequestId,
        requester_id: Id,
        write: Option&lt;Value&gt;, // `None` for read
        responses: BTreeMap&lt;Id, (Seq, Value)&gt;,
    },
    Phase2 {
        request_id: RequestId,
        requester_id: Id,
        read: Option&lt;Value&gt;, // `None` for write
        acks: BTreeSet&lt;Id&gt;,
    },
}

type Seq = (LogicalClock, Id); // `Id` for uniqueness
type LogicalClock = u64;
</code></pre>
<p>We are now ready to implement the protocol. Note that the implementation
intentionally avoids decomposing the message handlers into different function
calls because each call needs to manage shared actor state. Spreading state
mutation across multiple locations in the source code arguably makes the
implementation harder to follow (much like mutable global variables), and
functions are only used where they can be reasoned about locally.</p>
<p>An alternative composition strategy that does often work well for actor systems
involves distinguishing roles so that each has less state (having different
<code>AbdServer</code> and <code>AbdReplica</code> actors for example), although we will not do that
for this short example. The next chapter on the other hand will demonstrate how
to compose a system of different actor types.</p>
<pre><code class="language-rust ignore noplayground">#[derive(Clone)]
struct AbdActor {
    peers: Vec&lt;Id&gt;,
}

impl Actor for AbdActor {
    type Msg = RegisterMsg&lt;RequestId, Value, AbdMsg&gt;;
    type State = AbdState;
    type Timer = ();

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        AbdState {
            seq: (0, Id::from(0)),
            val: '?',
            phase: None,
        }
    }

    fn on_msg(&amp;self, id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        use RegisterMsg::*;
        match msg {
            Put(req_id, val) if state.phase.is_none() =&gt; {
                o.broadcast(&amp;self.peers, &amp;Internal(Query(req_id)));
                state.to_mut().phase = Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: src,
                    write: Some(val),
                    responses: {
                        let mut responses = BTreeMap::default();
                        responses.insert(id, (state.seq, state.val.clone()));
                        responses
                    },
                });
            }
            Get(req_id) if state.phase.is_none() =&gt; {
                o.broadcast(&amp;self.peers, &amp;Internal(Query(req_id)));
                state.to_mut().phase = Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: src,
                    write: None,
                    responses: {
                        let mut responses = BTreeMap::default();
                        responses.insert(id, (state.seq, state.val.clone()));
                        responses
                    },
                });
            }
            Internal(Query(req_id)) =&gt; {
                o.send(
                    src,
                    Internal(AckQuery(req_id, state.seq, state.val.clone())));
            }
            Internal(AckQuery(expected_req_id, seq, val))
                if matches!(state.phase,
                            Some(AbdPhase::Phase1 { request_id, .. })
                            if request_id == expected_req_id) =&gt;
            {
                let mut state = state.to_mut();
                if let Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: requester,
                    write,
                    responses,
                    ..
                }) = &amp;mut state.phase {
                    responses.insert(src, (seq, val));
                    if responses.len() == majority(self.peers.len() + 1) {
                        // Quorum reached. Move to phase 2.

                        // Determine sequencer and value.
                        let (_, (seq, val)) = responses.into_iter()
                            .max_by_key(|(_, (seq, _))| *seq)
                            .unwrap();
                        let mut seq = *seq;
                        let mut read = None;
                        let val = if let Some(val) = std::mem::take(write) {
                            seq = (seq.0 + 1, id);
                            val
                        } else {
                            read = Some(val.clone());
                            val.clone()
                        };

                        o.broadcast(
                            &amp;self.peers,
                            &amp;Internal(Replicate(*req_id, seq, val.clone())));

                        // Self-send `Replicate`.
                        if seq &gt; state.seq {
                            state.seq = seq;
                            state.val = val;
                        }

                        // Self-send `AckReplicate`.
                        let mut acks = BTreeSet::default();
                        acks.insert(id);

                        state.phase = Some(AbdPhase::Phase2 {
                            request_id: *req_id,
                            requester_id: std::mem::take(requester),
                            read,
                            acks,
                        });
                    }
                }
            }
            Internal(Replicate(req_id, seq, val)) =&gt; {
                o.send(src, Internal(AckReplicate(req_id)));
                if seq &gt; state.seq {
                    let mut state = state.to_mut();
                    state.seq = seq;
                    state.val = val;
                }
            }
            Internal(AckReplicate(expected_req_id))
                if matches!(state.phase,
                            Some(AbdPhase::Phase2 { request_id, ref acks, .. })
                            if request_id == expected_req_id &amp;&amp; !acks.contains(&amp;src)) =&gt;
            {
                let mut state = state.to_mut();
                if let Some(AbdPhase::Phase2 {
                    request_id: req_id,
                    requester_id: requester,
                    read,
                    acks,
                    ..
                }) = &amp;mut state.phase {
                    acks.insert(src);
                    if acks.len() == majority(self.peers.len() + 1) {
                        let msg = if let Some(val) = read {
                            GetOk(*req_id, std::mem::take(val))
                        } else {
                            PutOk(*req_id)
                        };
                        o.send(*requester, msg);
                        state.phase = None;
                    }
                }
            }
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>The test case confirms that this implementation is linearizable provided that
the network does not redeliver messages. Performing thorough model checking may
take up to several minutes (depending on your system's performance) and will
only be performed with a <code>--release</code> build.</p>
<pre><code class="language-rust ignore noplayground">    #[test]
    fn is_linearizable_quick() {
        let checker = base_model()
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![1]),
            }))
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![0]),
            }))
            .actor(RegisterActor::Client { put_count: 1, server_count: 2 })
            .actor(RegisterActor::Client { put_count: 1, server_count: 2 })
            .checker().threads(num_cpus::get()).spawn_dfs().join();
        checker.assert_properties();
        assert_eq!(checker.unique_state_count(), 544);
    }

    #[test]
    #[cfg_attr(debug_assertions, ignore = &quot;enabled for --release only&quot;)]
    fn is_linearizable() {
        let checker = base_model()
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![1, 2]),
            }))
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![0, 2]),
            }))
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![0, 1]),
            }))
            .actor(RegisterActor::Client { put_count: 1, server_count: 2 })
            .actor(RegisterActor::Client { put_count: 1, server_count: 2 })
            .checker().threads(num_cpus::get()).spawn_dfs().join();
        checker.assert_properties();
        assert_eq!(checker.unique_state_count(), 37_168_889);
    }

    fn base_model()
        -&gt; ActorModel&lt;
            RegisterActor&lt;AbdActor&gt;,
            (),
            LinearizabilityTester&lt;Id, Register&lt;char&gt;&gt;&gt;
    {
        ActorModel::new(
                (),
                LinearizabilityTester::new(Register('?'))
            )
            .init_network(Network::new_unordered_nonduplicating([]))
            .property(Expectation::Always, &quot;linearizable&quot;, |_, state| {
                state.history.serialized_history().is_some()
            })
            .property(Expectation::Sometimes, &quot;value chosen&quot;, |_, state| {
                state.network.iter_deliverable().any(|e| {
                    if let RegisterMsg::GetOk(_, value) = e.msg {
                        return *value != '?';
                    }
                    return false
                })
            })
            .record_msg_in(RegisterMsg::record_returns)
            .record_msg_out(RegisterMsg::record_invocations)
    }
</code></pre>
<h2><a class="header" href="#complete-implementation" id="complete-implementation">Complete Implementation</a></h2>
<p>Here is the complete implementation for <code>main.rs</code>:</p>
<pre><code class="language-rust ignore noplayground">use serde::{Deserialize, Serialize};
use stateright::actor::{*, register::*};
use std::borrow::Cow;
use std::collections::{BTreeMap, BTreeSet};
use std::fmt::Debug;
use std::hash::Hash;
use std::net::{SocketAddrV4, Ipv4Addr};

type RequestId = u64;
type Value = char;

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[derive(Serialize, Deserialize)]
enum AbdMsg {
    Query(RequestId),
    AckQuery(RequestId, Seq, Value),
    Replicate(RequestId, Seq, Value),
    AckReplicate(RequestId),
}
use AbdMsg::*;

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
struct AbdState {
    seq: Seq,
    val: Value,
    phase: Option&lt;AbdPhase&gt;,
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
enum AbdPhase {
    Phase1 {
        request_id: RequestId,
        requester_id: Id,
        write: Option&lt;Value&gt;, // `None` for read
        responses: BTreeMap&lt;Id, (Seq, Value)&gt;,
    },
    Phase2 {
        request_id: RequestId,
        requester_id: Id,
        read: Option&lt;Value&gt;, // `None` for write
        acks: BTreeSet&lt;Id&gt;,
    },
}

type Seq = (LogicalClock, Id); // `Id` for uniqueness
type LogicalClock = u64;

#[derive(Clone)]
struct AbdActor {
    peers: Vec&lt;Id&gt;,
}

impl Actor for AbdActor {
    type Msg = RegisterMsg&lt;RequestId, Value, AbdMsg&gt;;
    type State = AbdState;
    type Timer = ();

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        AbdState {
            seq: (0, Id::from(0)),
            val: '?',
            phase: None,
        }
    }

    fn on_msg(&amp;self, id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        use RegisterMsg::*;
        match msg {
            Put(req_id, val) if state.phase.is_none() =&gt; {
                o.broadcast(&amp;self.peers, &amp;Internal(Query(req_id)));
                state.to_mut().phase = Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: src,
                    write: Some(val),
                    responses: {
                        let mut responses = BTreeMap::default();
                        responses.insert(id, (state.seq, state.val.clone()));
                        responses
                    },
                });
            }
            Get(req_id) if state.phase.is_none() =&gt; {
                o.broadcast(&amp;self.peers, &amp;Internal(Query(req_id)));
                state.to_mut().phase = Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: src,
                    write: None,
                    responses: {
                        let mut responses = BTreeMap::default();
                        responses.insert(id, (state.seq, state.val.clone()));
                        responses
                    },
                });
            }
            Internal(Query(req_id)) =&gt; {
                o.send(
                    src,
                    Internal(AckQuery(req_id, state.seq, state.val.clone())));
            }
            Internal(AckQuery(expected_req_id, seq, val))
                if matches!(state.phase,
                            Some(AbdPhase::Phase1 { request_id, .. })
                            if request_id == expected_req_id) =&gt;
            {
                let mut state = state.to_mut();
                if let Some(AbdPhase::Phase1 {
                    request_id: req_id,
                    requester_id: requester,
                    write,
                    responses,
                    ..
                }) = &amp;mut state.phase {
                    responses.insert(src, (seq, val));
                    if responses.len() == majority(self.peers.len() + 1) {
                        // Quorum reached. Move to phase 2.

                        // Determine sequencer and value.
                        let (_, (seq, val)) = responses.into_iter()
                            .max_by_key(|(_, (seq, _))| *seq)
                            .unwrap();
                        let mut seq = *seq;
                        let mut read = None;
                        let val = if let Some(val) = std::mem::take(write) {
                            seq = (seq.0 + 1, id);
                            val
                        } else {
                            read = Some(val.clone());
                            val.clone()
                        };

                        o.broadcast(
                            &amp;self.peers,
                            &amp;Internal(Replicate(*req_id, seq, val.clone())));

                        // Self-send `Replicate`.
                        if seq &gt; state.seq {
                            state.seq = seq;
                            state.val = val;
                        }

                        // Self-send `AckReplicate`.
                        let mut acks = BTreeSet::default();
                        acks.insert(id);

                        state.phase = Some(AbdPhase::Phase2 {
                            request_id: *req_id,
                            requester_id: std::mem::take(requester),
                            read,
                            acks,
                        });
                    }
                }
            }
            Internal(Replicate(req_id, seq, val)) =&gt; {
                o.send(src, Internal(AckReplicate(req_id)));
                if seq &gt; state.seq {
                    let mut state = state.to_mut();
                    state.seq = seq;
                    state.val = val;
                }
            }
            Internal(AckReplicate(expected_req_id))
                if matches!(state.phase,
                            Some(AbdPhase::Phase2 { request_id, ref acks, .. })
                            if request_id == expected_req_id &amp;&amp; !acks.contains(&amp;src)) =&gt;
            {
                let mut state = state.to_mut();
                if let Some(AbdPhase::Phase2 {
                    request_id: req_id,
                    requester_id: requester,
                    read,
                    acks,
                    ..
                }) = &amp;mut state.phase {
                    acks.insert(src);
                    if acks.len() == majority(self.peers.len() + 1) {
                        let msg = if let Some(val) = read {
                            GetOk(*req_id, std::mem::take(val))
                        } else {
                            PutOk(*req_id)
                        };
                        o.send(*requester, msg);
                        state.phase = None;
                    }
                }
            }
            _ =&gt; {}
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use stateright::{*, semantics::*, semantics::register::*};

    #[test]
    fn is_linearizable_quick() {
        let checker = base_model()
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![1]),
            }))
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![0]),
            }))
            .actor(RegisterActor::Client { put_count: 1, server_count: 2 })
            .actor(RegisterActor::Client { put_count: 1, server_count: 2 })
            .checker().threads(num_cpus::get()).spawn_dfs().join();
        checker.assert_properties();
        assert_eq!(checker.unique_state_count(), 544);
    }

    #[test]
    #[cfg_attr(debug_assertions, ignore = &quot;enabled for --release only&quot;)]
    fn is_linearizable() {
        let checker = base_model()
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![1, 2]),
            }))
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![0, 2]),
            }))
            .actor(RegisterActor::Server(AbdActor {
                peers: Id::vec_from(vec![0, 1]),
            }))
            .actor(RegisterActor::Client { put_count: 1, server_count: 2 })
            .actor(RegisterActor::Client { put_count: 1, server_count: 2 })
            .checker().threads(num_cpus::get()).spawn_dfs().join();
        checker.assert_properties();
        assert_eq!(checker.unique_state_count(), 37_168_889);
    }

    fn base_model()
        -&gt; ActorModel&lt;
            RegisterActor&lt;AbdActor&gt;,
            (),
            LinearizabilityTester&lt;Id, Register&lt;char&gt;&gt;&gt;
    {
        ActorModel::new(
                (),
                LinearizabilityTester::new(Register('?'))
            )
            .init_network(Network::new_unordered_nonduplicating([]))
            .property(Expectation::Always, &quot;linearizable&quot;, |_, state| {
                state.history.serialized_history().is_some()
            })
            .property(Expectation::Sometimes, &quot;value chosen&quot;, |_, state| {
                state.network.iter_deliverable().any(|e| {
                    if let RegisterMsg::GetOk(_, value) = e.msg {
                        return *value != '?';
                    }
                    return false
                })
            })
            .record_msg_in(RegisterMsg::record_returns)
            .record_msg_out(RegisterMsg::record_invocations)
    }
}

fn main() {
    env_logger::init_from_env(
        env_logger::Env::default().default_filter_or(&quot;info&quot;));
    let id0 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000));
    let id1 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3001));
    let id2 = Id::from(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3002));
    spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (id0, AbdActor { peers: vec![id1, id2] }),
            (id1, AbdActor { peers: vec![id0, id2] }),
            (id2, AbdActor { peers: vec![id0, id1] }),
        ]).unwrap();
}
</code></pre>
<h2><a class="header" href="#suggested-exercises" id="suggested-exercises">Suggested Exercises</a></h2>
<ol>
<li>
<p>This algorithm can be optimized by observing that the replication phases
need not replicate values if the quorum already agrees on a value. See if
you can implement this optimization.</p>
</li>
<li>
<p>More generally, replication messages only need to be sent to replicas that
disagree. See if you can implement this optimization as well.</p>
<blockquote>
<p>TIP: This is a slightly more complex optimization because we need to treat
&quot;all agree&quot; versus &quot;not all agree&quot; slightly differently to avoid dropping
requests in some cases. Can you see why?</p>
</blockquote>
</li>
<li>
<p>The current implementation also assumes that the network does not redeliver
messages. Revise it to account for potential message redelivery.</p>
</li>
</ol>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>This chapter provided the first taste of a real distributed algorithm. We were
able to incrementally infer a solution, but it was nontrivial. If there
were bugs in the code, they could be relatively difficult to identify without a
model checker.</p>
<p>In the next chapter, we will introduce the notion of &quot;consensus&quot; and implement
it via the Multi-Paxos algorithm. That chapter is not yet available, so in the
meantime you can learn more about Stateright by browsing additional <a href="https://github.com/stateright/stateright/tree/master/examples">Stateright
examples</a> and
reviewing the <a href="https://docs.rs/stateright">Stateright API docs</a>. If you are
familiar with TLA+, then the subsequent chapter <a href="./comparison-with-tlaplus.html">Comparison with
TLA+</a> may also be interesting to you.</p>
<p>If you have any questions, comments, or ideas, please share them on
<a href="https://discord.com/channels/781357978652901386">Stateright's Discord server</a>.
At this time Stateright is a small personal project, and the main author is
eager to hear community feedback.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="seeking-consensus.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="comparison-with-tlaplus.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="seeking-consensus.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="comparison-with-tlaplus.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
