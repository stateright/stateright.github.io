<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Getting Started - Building Distributed Systems With Stateright</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Building Distributed Systems With Stateright</a></li><li class="chapter-item expanded affix "><li class="part-title">Concepts</li><li class="chapter-item expanded "><a href="getting-started.html" class="active"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Protocols</li><li class="chapter-item expanded "><a href="taming-the-network.html"><strong aria-hidden="true">2.</strong> Taming the Network</a></li><li class="chapter-item expanded "><a href="seeking-consensus.html"><strong aria-hidden="true">3.</strong> Seeking Consensus</a></li><li class="chapter-item expanded "><a href="achieving-linearizability.html"><strong aria-hidden="true">4.</strong> Achieving Linearizability</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Achieving Consensus</div></li><li class="chapter-item expanded affix "><li class="part-title">Other Topics</li><li class="chapter-item expanded "><a href="comparison-with-tlaplus.html"><strong aria-hidden="true">6.</strong> Comparison with TLA+</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Building Distributed Systems With Stateright</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/stateright/stateright.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#chapter-1-getting-started" id="chapter-1-getting-started">Chapter 1: Getting Started</a></h1>
<blockquote>
<p><strong>IMPORTANT</strong>: Stateright is a relatively new framework and will be making breaking API
changes leading up to a 1.0 release, at which point the API will be considered
stable. If you plan to use Stateright for production scenarios, then please
<a href="https://github.com/stateright/stateright/issues/new">file a GitHub issue</a> so
that the author can coordinate with you to minimize any disruption.</p>
</blockquote>
<h2><a class="header" href="#staterights-value-proposition" id="staterights-value-proposition">Stateright's Value Proposition</a></h2>
<p>Stateright is a Rust library that simplifies implementing distributed systems
while more importantly providing a powerful mechanism for verification.</p>
<p>Verification of distributed systems is difficult because distributed algorithms
must be resilient to nondeterminism caused by concurrency such as threads
racing, but that's only part of the challenge.  Distributed algorithms also
need to account for the fact that computers typically interface via <a href="https://aphyr.com/posts/288-the-network-is-reliable">unreliable
networks</a> that will
periodically do things like reorder or lose messages (if you run your system in
&quot;the cloud,&quot; then it's running on an unreliable network).  Furthermore, often a
distributed algorithm is expected to continue working even if a subset of
computers crash at arbitrary points in their execution.  Designing algorithms
that continue working in the presence of this added nondeterminism is
nontrivial and error prone, which necessitates special tools for verifying
correctness.</p>
<p>One approach to verifying the correctness of distributed algorithms is to run
them in an environment that randomly introduces nondeterminism more frequently
than a normal environment would. This is the approach taken by
<a href="https://jepsen.io/analyses">Jepsen</a>, and it has proven to be incredibly
effective, finding bugs in distributed systems such as
<a href="https://jepsen.io/analyses/etcd-3.4.3">etcd</a>,
<a href="https://jepsen.io/analyses/postgresql-12.3">PostgreSQL</a>,
<a href="https://aphyr.com/posts/283-call-me-maybe-redis">Redis</a>, and
<a href="https://aphyr.com/posts/291-call-me-maybe-zookeeper">Zookeeper</a> among many
others.</p>
<p>Stateright's approach is similar, but rather than testing a random subset of
possible behaviors, it tests <em>all possible observable behaviors</em> within a
particular specification.  The catch is that Stateright needs to be embedded
into the system's implementation, whereas solutions such as Jepsen do not,
making them amenable to testing a wider range of software; but if you are
writing a distributed system in Rust, then Stateright can provide additional
verification over random testing.</p>
<h2><a class="header" href="#an-example" id="an-example">An Example</a></h2>
<p>Let's start with the simplest nontrivial distributed system: a single client
that can interact with a single server by reading or writing a value. We'll see
that even this minimal example is susceptible to surprising behavior.</p>
<p><a href="https://www.rust-lang.org/learn/get-started">Install the Rust programming
language</a> if it is not already
installed, then initialize a new project using the <code>cargo</code> utility included
with Rust. If you are new to Rust, then you should also review some of the
language's <a href="https://www.rust-lang.org/learn">learning resources</a>.</p>
<pre><code class="language-sh">mkdir getting-started
cd getting-started
cargo init
</code></pre>
<p>Define dependencies in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[package]
name = &quot;getting-started&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Jonathan Nadal &lt;jon.nadal@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
env_logger = &quot;0.7&quot;
serde_json = &quot;1.0&quot;
stateright = &quot;0.23&quot;
</code></pre>
<p>Here is the complete implementation for <code>main.rs</code>. Copy-paste it into your own
file. The subsequent sections will explain further.</p>
<pre><code class="language-rust ignore noplayground">use stateright::actor::{*, register::*};
use std::borrow::Cow; // COW == clone-on-write
use std::net::{SocketAddrV4, Ipv4Addr};

type RequestId = u64;

#[derive(Clone)]
struct ActorContext;

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = char;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        '?' // default value for the register
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                *state.to_mut() = value;
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, **state));
            }
            _ =&gt; {}
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use stateright::*;
    use RegisterMsg::{Get, GetOk, Put, PutOk};
    use SystemAction::Deliver;

    #[test]
    fn is_unfortunately_not_linearizable() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(1) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(2, 'Z') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(2) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Get(3) },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: GetOk(3, 'A') },
        ]);
    }
}

fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000), ActorContext)
        ]).unwrap();
}
</code></pre>
<h2><a class="header" href="#actor-framework-intro" id="actor-framework-intro">Actor Framework Intro</a></h2>
<p>The code implements a simple server using the <a href="https://en.wikipedia.org/wiki/Actor_model">actor
model</a>  in which an &quot;actor&quot; is an
object that can respond to events (such as timeouts or message receipt) and in
turn updates its internal state and generates outputs (such as sending a
message or setting a timer).</p>
<p>If you are familiar with the actor model (e.g. via the
<a href="https://www.erlang.org/">Erlang</a> language or the <a href="https://akka.io/">Akka</a>
library), then it is useful to note distinguishing characteristics of
Stateright's approach:</p>
<ol>
<li>Stateright <strong>must have visibility of every input and output</strong> to facilitate
simulating all possible system behaviors. That means inputs and outputs must
be in the form of messages. For example, if your actor needs to interface
with a database, you might introduce <code>DbExec(...)</code> output and
<code>DbResult(...)</code> input messages; or if it needs to interface with the file
system, you might introduce <code>FileRead(...)</code> output and <code>FileResult(...)</code>
input messages. An adapter layer would then translate these into the
corresponding effects rather than treating them as standard messages between
actors in the system. This technique will be demonstrated in a later
chapter.</li>
<li>Outputs <strong>do not take effect until after the handler returns</strong>. The outputs
are simply collected in the <a href="https://docs.rs/stateright/latest/stateright/actor/struct.Out.html"><code>o: &amp;mut Out&lt;Self&gt;</code></a>
parameter whenever methods such as
<a href="https://docs.rs/stateright/latest/stateright/actor/struct.Out.html#method.send"><code>Out::send(...)</code></a>
are called, and Stateright's actor runtime sends them later.</li>
<li>The <strong>actor state is only accessible via a clone-on-write cell</strong> with the
<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>state: &amp;mut Cow&lt;Self::State&gt;</code></a>
parameter. Doing so enables Stateright to more efficiently validate a system
when it is enumerating different branches of nondeterministic behavior.</li>
</ol>
<h2><a class="header" href="#implementation-walkthrough" id="implementation-walkthrough">Implementation Walkthrough</a></h2>
<p>The server responds to <code>Put</code> and <code>Get</code> messages based only on its own local
state, providing its clients with a simple form of distributed storage,
sometimes known as a <a href="https://en.wikipedia.org/wiki/Shared_register">shared
register</a>.  Responses are linked
to requests via a request ID chosen by the client.</p>
<pre><code class="language-rust ignore noplayground">type RequestId = u64;

#[derive(Clone)]
struct ActorContext;

impl Actor for ActorContext {
    type Msg = RegisterMsg&lt;RequestId, char, ()&gt;;
    type State = char;

    fn on_start(&amp;self, _id: Id, _o: &amp;mut Out&lt;Self&gt;) -&gt; Self::State {
        '?' // default value for the register
    }

    fn on_msg(&amp;self, _id: Id, state: &amp;mut Cow&lt;Self::State&gt;,
              src: Id, msg: Self::Msg, o: &amp;mut Out&lt;Self&gt;) {
        match msg {
            RegisterMsg::Put(req_id, value) =&gt; {
                *state.to_mut() = value;
                o.send(src, RegisterMsg::PutOk(req_id));
            }
            RegisterMsg::Get(req_id) =&gt; {
                o.send(src, RegisterMsg::GetOk(req_id, **state));
            }
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>A test follows. The test checks the system for a property called
<a href="https://en.wikipedia.org/wiki/Linearizability">linearizability</a>, which loosely
speaking means that the visible behavior of the register emulated by the actor
system is identical to that of a register within a single-threaded system. In
the words of the individuals who coined the term:</p>
<blockquote>
<p>Linearizability provides the illusion that each operation applied by
concurrent processes takes effect instantaneously at some point between its
invocation and its response, implying that the meaning of a concurrent object’s
operations can be given by pre- and post-conditions.</p>
<ul>
<li>Maurice Herlihy and Jeannette Wing, in <a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.142.5315">Linearizability: A Correctness
Condition for Concurrent
Objects</a></li>
</ul>
</blockquote>
<p>An important aspect of linearizability is the notion of a &quot;sequential
specification,&quot; which serves as a reference for correct behavior of the system.
In other words, the system <em>emulates</em> the sequential specification.
For instance, the sequential specification could indicate:</p>
<ul>
<li>the system behaves like a memory cell (i.e. register semantics),</li>
<li>the system behaves like a queue,</li>
<li>or the system behaves like a stack.</li>
</ul>
<p>That means that when someone indicates that a system is linearizable, it is
important to keep in mind the question &quot;linearizable with respect to <em>what</em>?&quot;
In this chapter, the sequential specification is register semantics, provided
by Stateright, but later chapters will involve other sequential specifications.</p>
<p>The test leverages
<a href="https://docs.rs/stateright/latest/stateright/actor/register/struct.RegisterTestSystem.html"><code>RegisterTestSystem</code></a>,
which is built into Stateright and defines a system whereby a specified number
of clients (only 1 in this case) write distinct values and independently read
values without coordinating with one another. Under the hood
<code>RegisterTestSystem</code> also leverages Stateright's built-in
<a href="https://docs.rs/stateright/latest/stateright/semantics/struct.LinearizabilityTester.html"><code>LinearizabilityTester</code></a>.</p>
<pre><code class="language-rust ignore noplayground">    #[test]
    fn is_unfortunately_not_linearizable() {
        let checker = RegisterTestSystem {
            servers: vec![ActorContext],
            client_count: 1,
            .. Default::default()
        }.into_model().checker().spawn_dfs().join();
        //checker.assert_properties(); // TRY IT: Uncomment this line, and the test will fail.
        checker.assert_discovery(&quot;linearizable&quot;, vec![
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(1) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(2, 'Z') },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(2) },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
            Deliver { src: Id::from(1), dst: Id::from(0), msg: Get(3) },
            Deliver { src: Id::from(0), dst: Id::from(1), msg: GetOk(3, 'A') },
        ]);
    }
</code></pre>
<p>Stateright is able to find a bug that arises even if there is only a single
client. The test indicates a sequence of steps that trigger the bug (AKA a
<a href="https://docs.rs/stateright/0.23.0/stateright/struct.Path.html"><code>Path</code></a>), but
in practice you would normally just call <code>checker.assert_properties()</code>, and
Stateright would fail the test while indicating steps that reproduce the bug
(although the specific example that it finds can vary).</p>
<p>The actor with <code>Id</code> 0 is the server while the actor with <code>Id</code> 1 is the client.
For brevity, the example shows actor inputs (<code>Deliver</code>) but not outputs.</p>
<p><img src="getting-started.sequence.png" alt="sequence diagram for the linearizability violation" /></p>
<ol>
<li>The server receives a <code>Put</code> from the client with value <code>'A'</code>, which it
acknowledges. The client receives the <code>PutOk</code> acknowledgement and in turn
sends a second <code>Put</code> with a new value, <code>'Z'</code> (not shown yet since the test
indicates messages deliveries only, not message sends).
<pre><code>Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(1) },
</code></pre>
</li>
<li>The server receives the second <code>Put</code>, which it acknowledges. The client
receives the <code>PutOk</code> acknowledgement and in turn sends a <code>Get</code> request (not
shown yet), expecting to read <code>'Z'</code>.
<pre><code>Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(2, 'Z') },
Deliver { src: Id::from(0), dst: Id::from(1), msg: PutOk(2) },
</code></pre>
</li>
<li>The network redelivers the first write, inadvertently overwriting the second:
<pre><code>Deliver { src: Id::from(1), dst: Id::from(0), msg: Put(1, 'A') },
</code></pre>
</li>
<li>The server receives the earlier <code>Get</code> request and replies with <code>'A'</code>. The
client receives the unexpected value, which violates linearizability because
from the perspective of the client, the system is not behaving as a
single-threaded register.
<pre><code>Deliver { src: Id::from(1), dst: Id::from(0), msg: Get(3) },
Deliver { src: Id::from(0), dst: Id::from(1), msg: GetOk(3, 'A') },
</code></pre>
</li>
</ol>
<p>The last bit of code defines the <code>main</code> method, which allows you to run the
actor on UDP port 3000, encoding messages with the JSON format.</p>
<pre><code class="language-rust ignore noplayground">fn main() {
    env_logger::init_from_env(env_logger::Env::default().default_filter_or(&quot;info&quot;));
    spawn(
        serde_json::to_vec,
        |bytes| serde_json::from_slice(bytes),
        vec![
            (SocketAddrV4::new(Ipv4Addr::LOCALHOST, 3000), ActorContext)
        ]).unwrap();
}
</code></pre>
<h2><a class="header" href="#running" id="running">Running</a></h2>
<p>Confirm the system behaves as expected by running the test, which should pass
because the test asserts that the bug exists. Include the <code>--release</code> flag so
that Rust fully optimizes the code even during testing, as Stateright tests are
computationally intensive and can be time consuming.</p>
<pre><code class="language-sh">cargo test --release
</code></pre>
<p>Now run the actor on a UDP socket.</p>
<pre><code class="language-sh">cargo run --release
</code></pre>
<p>If using a POSIX-oriented operating system,
<a href="https://en.wikipedia.org/wiki/Netcat">netcat</a> can be used to interact with the
actor from a different terminal window. Actor responses are omitted from the
listing below for clarity, but you will see messages such as <code>{&quot;PutOk&quot;:0}</code>
printed to STDOUT. Numbers in the messages are request IDs, the importance of
which will be more evident in the next chapter.</p>
<pre><code class="language-sh">nc -u localhost 3000
{&quot;Put&quot;:[0,&quot;X&quot;]}
{&quot;Get&quot;:1}
{&quot;Put&quot;:[2,&quot;X&quot;]}
{&quot;Get&quot;:3}
</code></pre>
<h2><a class="header" href="#exercise" id="exercise">Exercise</a></h2>
<p>Uncomment the <code>// TRY IT</code> line, then run the test again. It should fail
indicating a sequence of steps that would cause the linearizability expectation
to be violated, and these steps may differ from the example that we followed.
This exercise demonstrates how Stateright can detect flaws that would likely go
undetected when simply reviewing code.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>This chapter introduced one of the simplest possible distributed systems and
showed how Stateright can find a subtle bug. The next chapter <a href="./taming-the-network.html">Taming the
Network</a> will address that bug.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="title-page.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="taming-the-network.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="title-page.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="taming-the-network.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
